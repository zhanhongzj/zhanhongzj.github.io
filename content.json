{"meta":{"title":"我的博客","subtitle":"一天进步一点","description":"记录生活点滴","author":"zhanhong","url":"http://zhanhongzj.github.io"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-07-21T12:06:23.280Z","updated":"2017-08-01T09:33:50.555Z","comments":true,"path":"2017/07/21/hello-world/","link":"","permalink":"http://zhanhongzj.github.io/2017/07/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"浏览器是怎样工作的？","slug":"git用法","date":"2017-02-12T12:24:49.000Z","updated":"2017-08-01T11:50:50.626Z","comments":true,"path":"2017/02/12/git用法/","link":"","permalink":"http://zhanhongzj.github.io/2017/02/12/git用法/","excerpt":"","text":"0. 为什么要了解浏览器是如何工作的想要写出一个最佳实践的页面，要实现性能优化，就要好好了解了解浏览器的工作原理。 了解浏览器如何进行加载，可以在引用外部样式表文件、外部 JavaScript 文件时，将他们放到合适的位置，使浏览器以最快的速度及合理的顺序将文件加载完毕。 了解浏览器如何进行解析，可以在构建 DOM 结构，组织 CSS 选择器时，选择最优的写法，提高浏览器的解析效率。 了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写 JavaScript 文件时，可以减少 “reflow” “repaint” 的消耗。 1. 浏览器的主要功能及构成浏览器的主要功能 是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。 浏览器的主要构成 浏览器的主要组件包括： 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。 浏览器引擎 － 用来查询及操作渲染引擎的接口。 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来。 网络 － 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作。 UI 后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。 JS 解释器 － 用来解释执行 JS 代码。 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 web database 技术，这是一种轻量级完整的客户端存储技术。 2. 浏览器的渲染2.1 渲染引擎简介渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。 默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式，这里先不讨论插件及扩展，只讨论渲染引擎最主要的用途——显示应用了 CSS 之后的 html 及图片。 2.2 渲染流程 渲染引擎首先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成，即以 8K 每块下载 html 页面。 然后解析页面生成 DOM 树，遇到 CSS 标签或 JS 脚本标签就新起线程去下载他们，并继续构建 DOM。 CSS 下载完后解析为 CSS 规则树，浏览器结合 CSS 规则树和 DOM 树生成 Render Tree。Render Tree 由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。 JavaScript 下载后可以通过 DOM API 修改 DOM，通过 CSSOM(CSS Object Model) API 修改样式作用域 Render Tree。注意：构建 CSSOM 会阻塞 JavaScript 的执行，JavaScript 的执行也会阻塞 DOM 的构建。 每次修改会造成 Render Tree 的重新布局和重绘。只要修改 DOM 或修改了元素的形状或大小，就会触发 Reflow，单纯修改元素的颜色只需 Repaint 一下（调用操作系统 Native GUI 的 API 绘制）。 Render Tree 构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历 Render Tree，并使用 UI 后端层绘制每个节点。也可用下图描述： 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 Render Tree。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 2.3 reflow 与 repaint现在再表述一下 HTML 页面加载和解析的流程： 用户输入网址（假设是个 html 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 html 文件； 浏览器开始载入 html 代码，发现 \\ 标签内有一个 \\ 标签引用外部 CSS 文件； 浏览器发出 CSS 文件的请求，服务器返回这个 CSS 文件； 浏览器继续载入 html 中 \\ 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个 \\ 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行 JavaScript 代码的 \\ 标签，赶快运行它； JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 \\ （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了 \\ 的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 \\ 标签的 CSS 路径； 浏览器召集了在座的各位 \\\\\\\\ 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的 CSS 文件，重新渲染页面。 页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，我们称这个回退的过程叫 reflow。 reflow 几乎是无法避免的。现在常见的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击等，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 与 reflow 有个看上去差不多的术语叫 repaint (重绘)，如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的 repaint，重画某一部分。 2.4 引起 repaint 和 reflow 的一些操作DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的: 当你增加、删除、修改 DOM 结点时； 当你移动 DOM 的位置，或是搞个动画的时候； 当你修改 CSS 样式的时候； 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候； 当你修改网页的默认字体时； 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 2.5 reflow 优化reflow 是不可避免的，只能将 reflow 对性能的影响减到最小,给出下面几条建议： 1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className： // 不好的写法 var left = 10, top = 10; elem.style.left = left + &quot;px&quot;; elem.style.top = top + &quot;px&quot;; // 推荐写法 elem.className += &quot; classname&quot;; 2. 把 DOM 离线后修改。如： 使用 DocumentFragment 对象在内存里操作 DOM。 先把 DOM 给 display:none (有一次 reflow)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。 clone 一个 DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。 3. 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 4. 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较低的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。 5. 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是会大大减小 reflow 。 6. 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 reflow 要比 repaint 更花费时间，因为 reflow 也会引发 repaint，也就更影响性能。所以在写代码的时候，要尽量避免过多的 reflow。 以上这些仅是对浏览器工作原理的一个简单说明，大家如果对它感兴趣，可以继续搜索相关文章深入学习，因为我觉得理解浏览器的原理是很重要的，可以帮助我们写出性能更好的页面。 参考： http://taligarsiel.com/Projects/howbrowserswork1.htm https://segmentfault.com/a/1190000002629708","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"百科","slug":"百科","permalink":"http://zhanhongzj.github.io/tags/百科/"}]},{"title":"面试总结","slug":"面试总结7-26","date":"2017-02-12T12:24:49.000Z","updated":"2017-08-01T08:58:31.247Z","comments":true,"path":"2017/02/12/面试总结7-26/","link":"","permalink":"http://zhanhongzj.github.io/2017/02/12/面试总结7-26/","excerpt":"","text":"推荐的文章实例 上面有两道横线，第一道横线是区别front-matter（标题日期等信息）和文章内容，第二道横线则是为了将题图与文章其他内容区分开来，欢迎使用这样的一种方法，来让你的文章格式更好一点。 硬件篇 MOTO G 2014，2015年8月份买的，没有想到这么耐用(cao)，各种刷机折腾都没有问题，现在仍然是主力机。 Lenove E431（已停产），其实我也想用Mac,然而这是公司配的。 [Apple iPad mini 4](https://item.jd.com/1892003.html )，本来买回来是给老妈看视频聊微信用的，结果现在我每次回家总是占着它。 [吉列手动剃须刀锋速3](https://item.jd.com/959960.html )，配合剃须膏，手动刮胡子也是一种享受了。 [罗马仕 充电宝](https://item.jd.com/1232039.html )，10000 豪安刚刚好，用了也两年多了吧。 New Balance 574 ，从14年开始穿，作为基本款还是很不错的。软件篇 通用 翻墙服务 自购ss账户,搬瓦工vps备胎，改善浏览网络体验 这个文件最后的一道横线是用来区分是否在文章中标注版权信息，如果在_congig.yml 文件中设置了copyright: true ，则在此时添加结尾处横线加nocopyright，将会在单个文章中，取消版权声明。 ? 2017 Zhangolve nocopyright","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhanhongzj.github.io/tags/生活/"}]},{"title":"git用法","slug":"git的用法","date":"2017-02-12T12:24:49.000Z","updated":"2017-08-01T11:49:16.734Z","comments":true,"path":"2017/02/12/git的用法/","link":"","permalink":"http://zhanhongzj.github.io/2017/02/12/git的用法/","excerpt":"","text":"一、什么是 GitGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 是一个开源的分布式版本控制系统，用于敏捷高效的处理任何项目的版本问题。与常用的版本控制工具 CVS、SVN 等不同，Git 采用了分布式版本库的方式，不必服务器端软件支持。可以说 Git 是目前世界上最先进的分布式版本控制系统。 二、关于项目版本管理项目在开发的过程中，经常会出现多人分工协作进行项目开发并整合的过程，所以经常会出现一些协作开发时同步的问题，同时存在项目整体进度的控制和管理的问题，所以在程序开发行业衍生出来了版本管理工具。 版本管理工具，首先是一个内容管理工具，可以将项目的内容信息存放在版本管理服务器上方便项目组人员进行访问和查询修改。 版本管理具有里程碑意义的主要有三个阶段：CVS 阶段 –&gt; SVN 阶段 –&gt; Git 阶段。 1. CVS 阶段 项目搭建开发过程中，每次提交项目都会将整个项目提交到服务器进行保存，服务器存储着项目的 N 个备份，开发过程中的协作效率较低，同时也出现了各种传输的问题，所以慢慢淡出了行业。 2. SVN 阶段 考虑到 CVS 的缺陷，开发人员根据项目的实际情况，研发出专门针对项目版本控制的软件 Subversion（简称SVN），SVN 同样也需要搭建服务器，让项目组成员将数据存储在服务器上，但是每次改动并提交的时候，SVN 服务器并不重新保存整个项目的完整信息，而是和原来的项目进行对比，只保存改动的信息。这样就在很大的程度上对于项目版本服务器、项目协作效率有了显著的提升。所以至今为止，有很多公司依然选用 SVN 作为公司内部项目协作的版本控制软件。 3. Git 阶段 CVS 和 SVN 都是基于一个服务器的，如果脱离服务器，项目的版本保存就没有了任何意义，Git 恰恰处理了这样的问题。 4. Git 与 SVN 区别4.1 Git 是分布式的，而 SVN 不是SVN 是集中式版本控制系统，版本库是集中放在中央服务器的。通常我们干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后开始干活，活干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，加上网速慢的话，就纳闷了。 Git 是分布式版本控制系统，这是和其它非分布式的版本控制系统（SVN，CVS）最核心的区别。如果你能理解这个概念，那么你就已经上手一半了。 Git 跟 SVN 一样有自己的集中式版本库或服务器。但 Git 更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库的服务器上 chect out 代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，比如在飞机上，地下室，电梯里，通信欠发达的地区等，你仍然能够提交文件，查看历史版本记录，创建项目分支等。因为每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，版本都是在自己的电脑上。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。 4.2 Git 按照元数据的方式存储内容，SVN 是按照文件的形式存储所有的资源控制系统都是把文件的元信息隐藏在一个类似 .cvs、.svn、.git 的目录里。如果你把 .git 目录的体积大小跟 .svn 比较，你会发现它们差距很大。因为 .git 目录是你机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。 4.3 Git 和 SVN 中的分支不同分支在 SVN 中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行命令来确认代码是否被合并。所以，经常会发生有些分支被遗漏的情况。 然而，处理 Git 的分支却是相当的简单和有趣，你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。 4.4 Git 没有全局版本号，SVN 有目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。SVN的版本号实际是任何一个相应时间的源代码快照，它是从 CVS 进化到 SVN 的最大的一个突破。Git 可以使用 SHA-1 来唯一的标识一个代码快照，但这个并不能完全的代替 SVN 里容易阅读的数字版本号。 4.5 Git 内容的完整性优于 SVNGit 的内容存储使用的是 SHA-1 哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 三、Git 安装与配置1. 安装 以 windows 操作系统为例，以下操作均在 windows 7 32 bit 系统环境下进行。 在使用 Git 之前，我们需要安装 Git，下载地址：http://git-scm.com/downloads 选择 windows 操作平台（如果是其它系统对应选择即可）下载对应的安装包。 双击安装包开始安装，一路点击 “Next” 下一步即可，我在选择组件时将快捷方式添加到了桌面，以方便使用，当然不做任何修改全部使用默认推荐到最后安装完成也可。 安装完成后，在桌面可见到 Git Bash 的快捷方式，或是在开始菜单中可以找到 Git 文件夹： 或 2. 配置一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Users\\$USER。 用户信息第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录： 12$ git config --global user.name \"username\"$ git config --global user.email xxx@xxx.xx 若使用 git config 时用 –global 选项，读写的就是用户主目录下的 .gitconfig 文件。 查看配置信息1$ git config --list 四、Git 工作区、暂存区、版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage，或 index。一般存放在 “.git” 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 上图左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 从图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 五、Git 工作流程 一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 六、Git 基本操作1. 创建仓库版本库又叫仓库，英文名：repository，你可以简单的理解为一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件“还原”。 有两种取得 Git 仓库的方法，第一种是在现在的目录下，通过导入所有文件来创建新的 Git 仓库，第二种是从已有的 Git 仓库中克隆出一个新的镜像仓库来。 下面我们先使用第一种方式创建 Git 仓库（第二种创建仓库的方式稍后讲解）。 1.1 初始化仓库我先在 F: 盘下创建了一个目录（git_test，相当于我们的工作区），从 Git Bash 中进入该目录，执行如下命令： 123456789101112131415161718$ git init``` 初始化后，在当前目录下会出现一个名为 .git 的隐藏目录，这个目录是 Git 来跟踪管理版本的，所有 Git 需要的数据和资源都存放在这个目录中，所以没事千万不要手动乱改这个目录里面的文件，否则可能会把 Git 仓库给破坏了。![](/images/posts/git/git_init.png)生成的隐藏目录：![](/images/posts/git/git_init_folder.png)#### 1.2 将文件添加到仓库中 ####在 git_test 目录下新建一个文本文件 readme.txt，内容为：version 1.0.1.10161117_beta。**跟踪文件**使用如下命令跟踪文件： $ git add 文件/目录路径1234567891011121314在 `git add` 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。其实 `git add` 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。![](/images/posts/git/add_readme.png)如果和上面一样，没有任何提示，说明已经添加成功了。我们可以使用 `cat` 命令查看文件内容：![](/images/posts/git/cat_readme.png)**提交到版本库**我们先使用 `git status` 来查看状态信息： $ git status12再使用命令 `git commit` 告诉 Git，把文件提交到仓库： $ git commit -m ‘info’123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142![](/images/posts/git/git_commit.png)从上图中 `git status` 可以看出，readme.txt 文件已被跟踪，并处于暂存状态。只要在 “Changes to be committed:” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。### 2. 修改文件 ###**暂存已修改文件**现在我们修改下之前已跟踪过的文件 readme.txt，在头部插入一行：version 1.0.2，然后再次运行 `git status` 命令，会看到这样的状态报告：![](/images/posts/git/modify_not_add.png)这说明已跟踪文件的内容发生了变化（readme.txt 文件已被修改），但还没有放到暂存区。要暂存这次更新，需要运行 `git add` 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。使用 `git add` 将 readme.txt 添加到暂存区，状态：![](/images/posts/git/modify_add.png)现在 readme.txt 已暂存，下一次 commit 提交时就会记录到仓库。假设此时，我们修改 readme.txt，继续在头部插入一行：version 1.0.3，保存后，又会是什么情况呢？![](/images/posts/git/modify_add_2.png)从上图中我们可以看到，readme.txt 文件出现了两次，一次是已暂存，一次是未暂存，这是怎么回事呢？实际上 Git 只不过暂存了你运行 `git add` 命令时的版本，如果现在提交，那么提交的是添加 \"version 1.0.3\" 前的版本，而非当前工作目录中的版本。所以，运行了 `git add` 之后又作了修改的文件，需要重新运行 `git add` 把最新版本重新暂存起来：![](/images/posts/git/modify_add.png)**查看已暂存和未暂存的更新**实际上 `git status` 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 `git diff` 命令。现在，我们来解决两个问题：当前做的哪些更新还没有暂存，有哪些更新已经暂存起来准备好了下次提交？ `git diff` 会使用文件补丁的格式显示具体添加和删除的行。我们将 readme.txt 文件中的 \"version 1.0.3\" 修改为 \"version 1.0.3_beta\"，然后继续在头部插入一行 \"version 1.0.4\"，查看状态：![](/images/posts/git/modify_add_2.png)要查看尚未暂存的文件了更新了哪些内容，使用 `git diff`：![](/images/posts/git/diff_not_staged.png)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 `git diff --staged` 命令。来看看实际的效果：![](/images/posts/git/diff_staged.png)注意，`git diff` 不跟参数是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。我们将刚做的修改提交到版本库中。在此之前，一定要确认还有什么修改过的或新建的文件还没有 `git add` 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：![](/images/posts/git/modify_commit.png)### 3. 撤销修改和删除文件 ####### 3.1 撤销修改 ###我现在在 readme.txt 文件里面头部插入一行内容为：version 1.0.5，我们先查看一下：![](/images/posts/git/modify_add_3.png)在未提交之前，如果发现添加的内容有误，得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 `git add` 添加到暂存区，最后 commit。第二：使用 `git reset --hard HEAD^` 回退到上一个版本（稍后讲解）。第三：通过上图我们可以看到提示使用 `git checkout -- &lt;file&gt;...` 来丢弃已做的修改。![](/images/posts/git/git_checkout.png)命令 `git checkout -- readme.txt` 意思就是，把readme.txt文件在工作区做的修改全部撤销。但对于 readme.txt 的修改也可能存在以下两种情况：一种情况是：readme.txt 修改后，还没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态，上图显示的就是这种情况。另外一种是 readme.txt 已经放入暂存区，接着再一次作了修改，撤销修改就回到添加暂存区后的状态，如下所示：![](/images/posts/git/git_checkout_2.png)再作一次修改：![](/images/posts/git/git_checkout_3.png)撤销修改后：![](/images/posts/git/git_checkout_4.png)我们可以看到，撤销修改回到的状态是将 readme.txt 添加到暂存区后的状态。#### 3.2 删除文件 ####现在我们在工作区添加一个文件 profile.txt，然后提交。如下所示：![](/images/posts/git/add_profile.png)这时，我们发现刚添加的文件有错误，需要删除。一般情况下，我们直接在工作区将刚添加的 profile.txt 文件删除，但当我们再使用 `git status` 时，情况如下：![](/images/posts/git/delete_file.png)此时有两个选择，一个是使用 `git add/rm &lt;file&gt;...` 删除后再提交保存到版本库，一个是撤销删除操作。提交保存到版本库：![](/images/posts/git/git_add_rm.png)或![](/images/posts/git/git_add_rm_2.png)使用 `git add/rm &lt;file&gt;...` 是将状态存入暂存区，然后使用 `git commit -m 'info'` 提交保存到版本库中。使用 `git checkout -- &lt;file&gt;...` 撤销删除的操作：![](/images/posts/git/git_add_rm_3.png)需要注意的是，当不是通过直接在工作区删除文件，而是通过 `git rm &lt;file&gt;...` 删除了工作区文件，需要通过版本回退的方式撤销删除动作。### 4. 版本回退 ####### 4.1 查看提交历史 ####在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 `git log` 命令查看。![](/images/posts/git/git_log.png)默认不用任何参数的话，`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进显示提交说明。`git log` 有个常用的 --pretty 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 oneline 将每个提交放在一行显示，这在提交数很大时非常有用。![](/images/posts/git/git_log_pretty_oneline.png)#### 4.2 回退 ####为方便演示，我再多次修改并提交版本库。![](/images/posts/git/modify_add_more.png)现在我想使用版本回退操作，把当前的版本回退到上一个版本，使用命令： $ git reset –hard HEAD^12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758该命令的作用是重置当前分支的 HEAD 为指定的 HEAD^（HEAD^ 表示当前版本的上一个版本，也可以用 HEAD^^ 表示上上一个版本，以此类推），同时重置暂存区和工作区，与指定的 HEAD^ 一致。![](/images/posts/git/reset_head.png)那如果再向前回退4个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：`git reset --hard HEAD~4` 即可：![](/images/posts/git/reset_head_4.png)使用 `git log` 查看日志：![](/images/posts/git/git_log_reset.png)可以看到，现在版本为最初始化的第一个版本信息。现在又有一个问题出现了，如果我在版本回退时发现现在回退到的这个版本不是我所需要的，而是需要回退到 version 1.0.4 所在的版本，又该怎么办呢？`git log` 不能察看已经删除了的 commit 记录，`git reflog` 则可以查看所有分支的所有操作记录（包括 commit 和 reset 的操作），包括已经被删除的 commit 记录。![](/images/posts/git/git_reflog.png)最前边一列是对应各版本的版本号，我们可以通过版本号来实现回退：![](/images/posts/git/git_reset_version.png)现在我们再查看，readme.txt 文件中的内容就为我们需要回退到的版本内容了。## 七、分支管理 ##几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。在前边的图片中，我们基本都可以看到这样的内容：![](/images/posts/git/default_master.png)这是每次操作所在的分支说明，master 分支是默认分支。### 1. 新建与合并分支 ###实际工作中（比如开发一个网站）大概会是这样的工作流程：1. 为实现某个新的需求，创建一个分支。 2. 在这个分支上开展工作。假设此时，你突然接到一个电话说有个很严重的 bug 需要紧急修复，那么可以接着按照下面的步骤处理：3. 返回到原先已经发布到生产服务器上的分支。 4. 为这次紧急修复建立一个新分支，并在其中修复问题。5. 通过测试后，回到生产服务器所在的分支，将修复分支合并进来，然后再推送到生产服务器上。6. 切换到之前实现新需求的分支，继续工作。#### 1.1 新建分支 ####**创建分支**使用如下命令来创建分支： $ git branch branch_name123456![](/images/posts/git/git_branch_dev.png)**切换分支**我们已经创建了一个新分支：dev，但当前分支仍然为 master 分支，所以还需要使用切换分支命令来切换操作： $ git checkout branch_name123456789![](/images/posts/git/git_branch_checkout.png)已成功切换到 dev 分支了。**创建并切换分支**我们也可以使用如下命令来新建并切换分支： $ git checkout -b branch_name123456![](/images/posts/git/git_branch_checkout_bug.png)**列出分支**使用命令： $ git branch12345678910111213141516171819202122232425262728如：![](/images/posts/git/git_branch.png)**向分支提交版本库**下面我们向新分支 dev 中添加一个文件：![](/images/posts/git/add_index_to_dev.png)我们来看一下工作区目录结构：![](/images/posts/git/dev_folder.png)接下来切换回 master 分支：![](/images/posts/git/git_checkout_master.png)再看一下工作区目录结构：![](/images/posts/git/master_folder.png)比较两个不同分支下的目录结构，我们可以发现，在 dev 分支下保存到版本库中的文件 index.html，在 master 分支下看不见了。这是因为当切换分支的时候，Git 会用该分支的最后提交的快照替换工作目录的内容。#### 1.2 合并分支 ####如果我们需要将在 dev 分支版本库中的内容也添加到 master 分支中来，则需要合并分支： $ git merge123456789101112131415161718192021222324252627282930313233343536373839404142![](/images/posts/git/git_merge.png)合并后工作区目录结构：![](/images/posts/git/dev_folder.png)当然，合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。**合并冲突**首先在 master 分支下新建一个文本文件 site.txt 并提交，文本内容为 \"http://www.mobiletrain.org/\"，如下所示：![](/images/posts/git/add_site.png)创建一个新分支 dev，在新分支中修改 site.txt 并提交，文件内容为 \"http://www.1000phone.com/\"，如下所示：![](/images/posts/git/modify_site.png)切换回 master 分支，再查看 site.txt 文件内容：![](/images/posts/git/git_checkout_master_2.png)当前 master 分支中没有未提交的修改，我们继续在 master 分支中修改 site.txt，向文件末尾添加一行 \"http://www.codingke.com/\" 的内容：![](/images/posts/git/modify_site_2.png)接下来，把 dev 分支中的内容合并过来：![](/images/posts/git/git_merge_2.png)这时，一个合并冲突就出现了，我们需要手动修改冲突，修改完毕后：![](/images/posts/git/git_merge_conflict.png)确保冲突合并修改完毕后，提交到版本库中：![](/images/posts/git/git_merge_conflict_fixed.png)#### 1.3 删除分支 ####合并完成后，我们可以接着删除dev分支了，命令： $ git branch -d branch_name123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354如：![](/images/posts/git/git_branch_del.png)## 八、Git 远程仓库 ##Git 并不像 SVN 那样有个中心服务器。目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。你就需要将数据放到一台其他开发人员能够连接的服务器上。以下的介绍使用了 GitHub 作为远程仓库。### 1. GitHub 简介 ###如果你是一枚 Coder，但是你不知道 GitHub，那么我觉的你就不是一个菜鸟级别的 Coder，因为你压根不是真正 Coder，你只是一个 Code 搬运工。---- 菜鸟教程如是说。&gt; GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。&gt; &gt; GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。除了允许个人和组织创建和访问代码库以外，它也提供了一些方便社会化软件开发的功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于显示开发者们怎样在代码库上工作以及软件的开发活跃程度。&gt; &gt; 截止到2015年，GitHub已经有超过九百万注册用户和2110万代码库。事实上已经成为了世界上最大的代码存放网站和开源社区。这是[维基百科](https://zh.wikipedia.org/wiki/GitHub)对 GitHub 的介绍。我们先作为免费用户来使用一下 GitHub。免费用户只能使用公共仓库，也就是代码要公开。### 2. 注册账户 ###要想使用 GitHub，第一步当然是注册 GitHub 账号了。如果你已经注册过 GitHub 账号，请跳过这一步。GitHub 官网地址：[https://github.com/](https://github.com/)。![](/images/posts/git/register_github.png)根据向导注册即可，不再赘述。### 3. 创建仓库 ###登录 GitHub 后，点击导航栏中的 \"+\" 号，打开下拉菜单，选择 \"New Repository\" 新建仓库：![](/images/posts/git/create_repository.png)输入新仓库名称，其它直接使用默认值，点击 \"Create repository\" 按钮，创建仓库。![](/images/posts/git/create_repository_2.png)仓库创建成功后，可看到三种方式向仓库中添加版本库内容：![](/images/posts/git/create_repository_3.png)### 4. 配置 SSH key ###由于我们本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以需要作一下配置。**创建 SSH key**在用户主目录下，查看是否有一个名为 .ssh 的文件夹，如果有，打开查看是否存在 id_rsa 和 id_rsa.pub 这两个文件，如果存在，则可以复制 id_rsa.pub 文件中的内容，然后跳过此步骤（假如文件存在，但自己从未创建过 SSH key，也可以继续进行如下步骤），如果这些都不存在，则输入如下命令： $ ssh-keygen -t rsa -C ‘your_email@youremail.com’12345678910111213141516171819202122将 your_email@youremail.com 改为你在 GitHub 上注册的邮箱，之后会要求确认路径和输入密码，我直接使用默认的一路回车完成。成功的话会在用户主目录下生成 .ssh 文件夹，进入文件夹，使用文本工具打开 id_rsa.pub，我们可以看到文件里边一串文件信息，这是生成的 key，全选复制这些内容，以备后用。**配置 GitHub 账户**回到 GitHub，进入 Settings（配置）：![](/images/posts/git/account_setting.png)左边选择SSH and GPG Keys，打开页面中选择 New SSH key：![](/images/posts/git/ssh_keys.png)Title 随便填，Key 粘贴之前复制到剪贴板上的内容：![](/images/posts/git/add_ssh_key.png)点击 Add SSH key 按钮，完成配置：![](/images/posts/git/add_ssh_key_ok.png)为了验证是否成功，在 git bash 下输入： $ ssh -T git@github.com12345678910111213141516171819202122232425262728如果是第一次的会提示是否 Are you sure you want to continue connecting (yes/no)? ，输入 yes 就会看到：You've successfully authenticated, but GitHub does not provide shell access。这就表示已成功连上 GitHub。**远程仓库信息**要查看远程库的详细信息，可使用 `git remote –v`：![](/images/posts/git/remote.png)fetch 表示抓取分支，push 表示推送分支。### 5. 推送本地仓库至 GitHub ###我们在 GitHub 上创建仓库时，已经看到如下提示：![](/images/posts/git/push_an_existing_repository.png)根据该提示，在本地 git_test 仓库下运行这两条命令：![](/images/posts/git/git_push.png)输入登录 GitHub 的用户名与密码，等待本地仓库推送至 GitHub 完毕即可。推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样了：![](/images/posts/git/git_push_success.png)以后只要在本地作了提交，就可以通过如下命令： $ git push origin master123456789101112131415161718把本地 master 分支的最新修改推送到 GitHub 上了。现在我们就拥有了真正的分布式版本库了。### 6. 抓取远程仓库分支 ###如果是团队合作的项目，那么当有其他同事向远程仓库提交了新数据后，我们又该如何将最新版本数据从远程仓库同步到本地呢？我直接在 GitHub 的仓库中添加了一个新文件 new_file.txt（内容为：this file was created on the server），来模拟其他同事的提交：![](/images/posts/git/new_file_on_server.png)在更新最新版本到本地之前，我们先通过 `git status` 查看下本地状态，这样可以知道是否有修改过的文件没有提交，因为如果本地修改的文件没有提交而服务器中存在提交修改的版本，那么更新过程中导致更新过程中就可能产生冲突，所以通过查看状态确保本地全部提交过：![](/images/posts/git/git_status.png)下面我们来更新本地仓库，使用命令： $ git pull12345678910111213141516171819202122232425262728![](/images/posts/git/git_pull.png)查看本地工作区文件，可以看到服务器上的文件同步到本地仓库了：![](/images/posts/git/git_pull_2.png)也可以使用 `git fetch` 来抓取分支，它与 `git pull` 的区别在于：`git fetch` 相当于是从远程获取最新版本到本地，不会自动merge；`git pull` 相当于是从远程获取最新版本并merge到本地。### 7. 克隆远程版本库 ###上面我们了解了先有本地库，后有远程库的时候，如何关联远程库。现在我们想，假如先有的是远程库，要把远程库的内容克隆到本地来 如何克隆呢？首先，登录 GitHub，创建一个新的仓库，名字叫 git_test_clone。如下：![](/images/posts/git/new_repository.png)远程仓库准备好后，我们先复制远程仓库访问路径 URL：![](/images/posts/git/copy_address.png)我先在 F 盘下新建一个文件夹 clone，将从服务器上克隆的仓库放入该文件夹下，则执行如下命令克隆仓库： $ git clone URL1234567891011121314![](/images/posts/git/clone_repository.png)克隆成功后，我们就可以进入对应目录进行本地文件编辑了。![](/images/posts/git/clone_success.png)## 九、总结 ##到此，简单的 Git 使用就介绍完毕了，下面总结一下常用到的 Git 命令：日常使用命令：![](/images/posts/git/most_use.png) 在当前目录新建一个Git代码库$ git init 下载一个项目和它的整个代码历史$ git clone [url] 显示当前的Git配置$ git config –list 设置提交代码时的用户信息$ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]” 添加指定文件到暂存区$ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录$ git add [dir] 添加当前目录的所有文件到暂存区$ git add . 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] … 提交暂存区到仓库区$ git commit -m [message] 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a 提交时显示所有diff信息$ git commit -v 列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 新建一个分支，并切换到该分支$ git checkout -b [branch] 切换到指定分支，并更新工作区$ git checkout [branch-name] 切换到上一个分支$ git checkout - 合并指定分支到当前分支$ git merge [branch] 删除分支$ git branch -d [branch-name] 删除远程分支$ git push origin –delete [branch-name]$ git branch -dr [remote/branch] 显示有变更的文件$ git status 显示当前分支的版本历史$ git log 显示暂存区和工作区的差异$ git diff 显示暂存区和上一个commit的差异$ git diff –cached [file] 显示当前分支的最近几次提交$ git reflog 下载远程仓库的所有变动$ git fetch [remote] 显示所有远程仓库$ git remote -v 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 上传本地指定分支到远程仓库$ git push [remote] [branch] 恢复暂存区的指定文件到工作区$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致$ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset –hard [commit]``` 参考资料： http://www.cnblogs.com/wzyxidian/p/5520002.html http://www.runoob.com/git/git-tutorial.html http://www.cnblogs.com/tugenhua0707/p/4050072.html http://www.runoob.com/git/git-tutorial.html http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://zhanhongzj.github.io/tags/工具/"}]}]}