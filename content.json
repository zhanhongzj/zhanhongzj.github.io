{"meta":{"title":"我的博客","subtitle":"一天进步一点","description":"记录生活点滴","author":"zhanhong","url":"http://zhanhongzj.github.io"},"pages":[],"posts":[{"title":"面试总结","slug":"面试总结7-26","date":"2017-02-12T12:24:49.000Z","updated":"2017-08-01T08:58:31.247Z","comments":true,"path":"2017/02/12/面试总结7-26/","link":"","permalink":"http://zhanhongzj.github.io/2017/02/12/面试总结7-26/","excerpt":"","text":"推荐的文章实例 上面有两道横线，第一道横线是区别front-matter（标题日期等信息）和文章内容，第二道横线则是为了将题图与文章其他内容区分开来，欢迎使用这样的一种方法，来让你的文章格式更好一点。 硬件篇 MOTO G 2014，2015年8月份买的，没有想到这么耐用(cao)，各种刷机折腾都没有问题，现在仍然是主力机。 Lenove E431（已停产），其实我也想用Mac,然而这是公司配的。 [Apple iPad mini 4](https://item.jd.com/1892003.html )，本来买回来是给老妈看视频聊微信用的，结果现在我每次回家总是占着它。 [吉列手动剃须刀锋速3](https://item.jd.com/959960.html )，配合剃须膏，手动刮胡子也是一种享受了。 [罗马仕 充电宝](https://item.jd.com/1232039.html )，10000 豪安刚刚好，用了也两年多了吧。 New Balance 574 ，从14年开始穿，作为基本款还是很不错的。软件篇 通用 翻墙服务 自购ss账户,搬瓦工vps备胎，改善浏览网络体验 这个文件最后的一道横线是用来区分是否在文章中标注版权信息，如果在_congig.yml 文件中设置了copyright: true ，则在此时添加结尾处横线加nocopyright，将会在单个文章中，取消版权声明。 ? 2017 Zhangolve nocopyright","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhanhongzj.github.io/tags/生活/"}]},{"title":"SASS 使用教程","slug":"css-sass","date":"2017-01-10T14:29:45.000Z","updated":"2017-08-02T09:25:58.910Z","comments":true,"path":"2017/01/10/css-sass/","link":"","permalink":"http://zhanhongzj.github.io/2017/01/10/css-sass/","excerpt":"","text":"1. 简介以前我们在写 CSS 时，通常都是直接在外部 CSS 文件中一个属性一个属性的敲，如果要实现代码的复用，那就 ctrl+c 和 ctrl+v 了，如果要使用某个 RGB 颜色值，还得一遍遍的翻回去复制。这样的开发效率很低，并且也很烦琐，因为 CSS 并不是编程语言，所以也就不能像写 JavaScript 代码一样来实现流程控制等操作了。 幸运的是现在我们有了“CSS预处理器”（css preprocessor），在 CSS 中加入了编程元素，当然不是直接使用 CSS 来实现编程，而是使用专门的编程语言，进行设计后再编译成 CSS 文件。 这种“CSS预处理器”也有很多种，参见8 CSS preprocessors to speed up development time，本文主要介绍 SASS 的使用。 2. SASS 安装与使用 2.1 安装要使用 SASS 首先需要安装 SASS 环境，可参见：http://sass-lang.com/install。 SASS 是基于 Ruby 语言写的，所以必须先安装 Ruby，但是 SASS 与 Ruby 的语法没有关系，即使完全不懂 Ruby，也可以使用 SASS。 windows 系统中安装 Ruby 最快速的方式是使用 RubyInstaller。RubyInstaller 也会自动安装命令行工具让我们可以直接使用它的库。 Ruby 安装好后，打开命令提示符（win+r 运行框中输入 cmd 回车即可），输入以下命令： gem install sass 即可安装 SASS，但安装有时也会被墙，所以可以直接下载 SASS 的 gem 库离线安装，下载地址为：https://api.rubygems.org/gems/sass-3.4.22.gem。 下载后在命令提示符下直接安装： gem install d:/sass-3.4.22.gem 当然我们前边也安装了 Gulp 插件 gulp-sass，可以借助 Gulp 来实现 SASS 编译，也不用安装 Ruby。详情见 《Gulp 使用教程》。 2.2 使用SASS 文件就是普通的文本文件，可以直接使用 CSS 语法，文件后缀名是 .scss（3.0以前的版本通常使用 .sass 后缀）。 如果安装了 Ruby 环境和 SASS，则可以在命令提示符下输入： sass style.scss 会直接在屏幕上显示出 .scss 文件转换为 .css 文件后的样式内容。也可以继续跟上输出文件的路径名，将编译后的 CSS 内容保存到文件中： sass style.scss style.css 在编译成 CSS 时，SASS 提供四种编译风格： nested —- 嵌套缩进 expanded —- 没有缩进，扩展的 compact —- 简洁格式 compressed —- 压缩 默认是使用 nested 风格，在生产环境当中，一般使用最后一个（compressed）。 也可以让 SASS 监听某个文件或目录的修改，自动生成编译后的版本： sass --watch style.scss:style.css 或 sass --watch app/sass:public/stylesheets 如果没有安装 Ruby 环境而是使用 Gulp 插件，可参见 https://github.com/dlmanning/gulp-sass 的使用。 如： var gulp = require(&quot;gulp&quot;), sass = require(&quot;gulp-sass&quot;); gulp.task(&quot;sass&quot;, function(){ gulp.src(&quot;scss/*.scss&quot;) .pipe(sass({outputStyle:&quot;compact&quot;})) .pipe(gulp.dest(&quot;dist/css&quot;)); }); 3. SASS 基本语法3.1 注释SASS 中有三种注释： 单行注释 // 单行注释 在输出 CSS 文件时不保留该注释内容。 多行注释 /* * 多行注释内容 * 作者：小明 */ 在编译输出的非压缩格式的 CSS 文件中会保留，压缩输出格式中不会保留。 强制注释 /*! * 强制注释内容 */ 表示强制保留注释内容，不管输出什么格式。 3.2 变量SASS 中的所有变量都是以 $ 开头，后紧跟变量名称，变量名与变量值之间以冒号（:）分隔开： $width : 180px; $bgColor : #eaeaea; .container { width: $width; background-color: $bgColor; height: 360px; border:1px solid; } .box { width: $width; height:230px; } .cube { background-color: $bgColor; border: 1px solid; } 生成的 CSS 文件为： .container { width: 180px; background-color: #eaeaea; height: 360px; border: 1px solid; } .box { width: 180px; height: 230px; } .cube { background-color: #eaeaea; border: 1px solid; } 如果变量需要镶嵌在字符串之中，需要写在 #{} 之中，如： $l : left; $r : right; .box { margin-#{$l}: 30px; } .container { margin-#{$r}: 20px; } 生成的 CSS 文件为： .box { margin-left: 30px; } .container { margin-right: 20px; } 3.3 嵌套选择器嵌套 scss 文件： #container { .title { width:300px; height:200px; border:1px solid #ccc; } .main_body{ width:250px; height:350px; border:1px solid #ccc; border-radius:5px; } } 超级链接伪类样式的设计，SASS 中可以通过 &amp; 符号引用父属性： a { &amp;:link { text-decoration: none; color: black; } &amp;:visited { text-decoration: none; color: black; } &amp;:hover { text-decoration: underline; color: red; } &amp;:active { text-decoration: underline; color: gray; font-size: 18px; } } 属性嵌套 scss 文件： #container { background: { color : #ccc; image : url(imgs/001.png); position: top left; repeat: no-repeat; } } 属性嵌套使用得相对较少一些。 3.4 代码重用Mixin 混合 Mixin 类似于宏命令，可以实现代码块重用，使用 @mixin 命令定义代码块： @mixin left-block { width: 360px; line-height: 30px; background: #ccc; } .left_side_nav { @include left-block; } .left_side_fav { @include left-block; color : red; font-size: 12px; } 使用 @include 命令复用代码块。 @mixin 可以使用参数与默认值： @mixin left-block($width:300px) { width: $width; line-height: 30px; background: #ccc; } .left_side_nav { @include left-block(200px); } .left_side_fav { @include left-block; color : red; font-size: 12px; } 当使用 @include 调用代码块复用时，如果不使用默认值，则直接传递实际值即可，如果不传递值，则使用默认值，上述示例编译成 CSS： .left_side_nav { width: 200px; line-height: 30px; background: #ccc; } .left_side_fav { width: 300px; line-height: 30px; background: #ccc; color: red; font-size: 12px; } extend 继承/扩展 也可使用继承/扩展来减少重复代码实现代码重用，可以让一个选择器去继承另一个选择中所有的样式，使用命令 @extend： .left-block { width: 300px; line-height: 30px; background: #ccc; } .left_side_nav { @extend .left-block; } .left_side_fav { @extend .left-block; color : red; font-size: 12px; } import 导入 可使用 @import 命令导入外部文件，外部文件可以是 .scss 文件，也可以是 .css 文件，但当导入 .css 文件时，相当于是 CSS 中的 @import 命令： @import &apos;plugin.scss&apos;; @import &apos;../css/style.css&apos;; .cube { color:red; } 生成的 CSS： @import url(../css/style.css); .box { width: 300px; height: 200px; background: #ccc; } .cube { color: red; } 4. 流程控制指令@if 条件控制指令，类似于 JavaScript 中的简单 if 结构，即当 if 条件满足时执行指定的表达式，语法结构为： @if 条件 { // 条件为真时执行的样式 } 当然有 @if 就有配套的 @else，与 JavaScript 中的 if-else 是一个道理： @if 条件 { // 条件为真时执行的样式 } @else { // 条件为假时执行的样式 } 示例： $width : 360px; .container { @if $width / 3 &gt; 100 { border: 1px solid; padding: 10px; } @else { border:5px solid; padding:20px; } } @for 循环控制指令，类似于 JavaScript 中的 for 循环结构。语法： @for $var from &lt;start&gt; to &lt;end&gt; { // 循环体 } 示例： @for $var from 1 to 10 { .m-#{$var} {margin: #{$var}px;} } 生成 .m-1、.m-2 …… .m-10 10个样式。 @while 类似于 JavaScript 中的 while 循环，语法： @while 条件 { // 循环体 } 示例： $i : 10; @while $i &gt; 0 { .p-#{$i} {padding: #{$i}px}; $i : $i - 2; } @each @each 与 @for 类似，语法结构为： @each $var in &lt;list&gt; @each 常用于列表或映射数据的循环，示例： $list : info warning debug error; @each $var in $list { .icon-#{$var} { background-image:url(imgs/#{$var}.png); } } 5. 函数函数的功能主要是数据的运算，SASS 中可以将一些值交给函数进行处理，具体的处理方式由定义的函数具体的设计确定。 自定义函数的语法结构为： @function 函数名称(参数列表){ // 数据处理 } 示例： $colors : (light:#fff, dark:#000, gray:#ccc); @function color($name) { @return map-get($colors, $name); } .container { background-color: color(gray); } map-get($colors, $name) 的作用是获取 $colors 中名称为 $name 的值，变量 $colors 是一个 map 集合，保存的是名值对。 6. 小结本文将 SASS 使用过程中常用用法做了简单的总结，日常开发一般就不需要再去查官方文档了，如果有更深层次的使用或对某个用法不熟悉，也可查询官方文档，详情见：http://sass-lang.com/documentation/file.SASS_REFERENCE.html。","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://zhanhongzj.github.io/tags/CSS/"},{"name":"SASS","slug":"SASS","permalink":"http://zhanhongzj.github.io/tags/SASS/"}]},{"title":"gulp 使用教程","slug":"gulp用法","date":"2017-01-10T14:29:45.000Z","updated":"2017-08-02T12:43:52.989Z","comments":true,"path":"2017/01/10/gulp用法/","link":"","permalink":"http://zhanhongzj.github.io/2017/01/10/gulp用法/","excerpt":"","text":"1. 简介Gulp 是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 Gulp 是基于 Nodejs 的自动任务运行器， 她能自动化地完成 JavaScript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了 Unix 操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 通过本文，我们将学习如何使用 Gulp 来改变开发流程，从而使开发更加快速高效。大家也可参考 Gulp 中文网 阅读 API 文档。 要使用 Gulp 的一个大致流程是：安装 Nodejs -&gt; 全局安装 Gulp -&gt; 项目安装 Gulp 以及 Gulp 插件 -&gt; 配置 gulpfile.js -&gt; 运行任务 2. 安装2.1 安装 NodejsGulp 是基于 Nodejs 的，所以在安装 Gulp 前先安装 Nodejs。 进入 Nodejs 官网，会自动检测本地操作系统类型及位数，下载稳定版本的 Nodejs 安装程序。LTS 表示是稳定版本，Current 表示当前最新版本。本文下载的是 v6.9.2 LTS 版本。 下载后根据向导安装即可。 安装完毕 Nodejs 后即可测试是否安装成功。在命令提示符下（通常 windows 系统是 cmd，mac 系统是终端）输入 node -v 即可查看安装的 Nodejs 版本。 常用命令说明： node -v：查看安装的 Nodejs 版本，出现版本号，说明已正确安装nodejs。 npm -v：查看npm的版本号，npm是在安装 Nodejs 时一同安装的 Nodejs 包管理器。 2.2 npm 简介npm 是 node package manager 的简称，它是 Nodejs 的包管理器，用于 node 插件的管理，如安装、卸载、依赖管理等。 安装插件 npm install &lt;name&gt; [-g] [--save-dev] \\ 表示插件名称，如 gulp。 -g 表示全局安装。全局安装可以通过命令行在任何地方调用它，本地安装（非全局安装）将安装在定位目录的 node_modules 文件夹下，通过 require() 调用。 --save 表示将保存配置信息至 package.json 文件，package.json 是 Nodejs 项目配置文件。之所以要保存至 package.json，是因为 Nodejs 插件包相对来说非常庞大，将配置信息写入 package.json 并将其加入版本管理，其他开发者对应下载即可（命令提示符执行 npm install，则会根据 package.json 下载所有需要的包，npm install --production 只下载 dependencies 节点的包）。 -dev 表示保存至 package.json 的 devDependencies 节点，不指定 -dev 将保存至 dependencies 节点；一般保存在 dependencies 的像这些：express/ejs/body-parser 等。 卸载插件 npm uninstall &lt;name&gt; [-g] [--save-dev] 要卸载插件，不要直接删除本地插件包，需要使用上述命令来卸载。 更新插件 npm update &lt;name&gt; [-g] [--save-dev] 要更新全部插件，可使用npm update [--save-dev]。 2.3 cnpmnpm 安装插件是从国外服务器下载资源，受网络影响大，可能出现异常，可以使用淘宝镜像，淘宝镜像是一个完整 npmjs.org 镜像，可以用它代替官方版本，其同步频率目前为 10 分钟一次以保证尽量与官方服务同步。 为保证安装能够正常进行，推荐使用淘宝镜像。cnpm 安装命令为：npm install -g cnpm --registry=https://registry.npm.taobao.org。 cnpm 的用法与 npm 完全一致，只需要将执行 npm 命令的地方替换为 cnpm 即可。 2.4 全局安装 Gulp为了在任何地方都可以使用到 Gulp 命令来执行任务，我们全局安装 Gulp，可以在命令提示符下使用 npm install gulp -g 或 cnpm install gulp -g 来实现安装。 等待安装结束，可使用 gulp -v 命令测试 Gulp 版本，如果看到版本号出现，则说明安装成功。本文 Gulp 版本为 3.9.1。 2.5 生成 package.jsonpackage.json 是基于 Nodejs 项目必不可少的配置文件，它是存放在项目根目录的 json 文件。 package.json 用来存放即将安装的插件 name 和 version，这个文件有什么用呢？当我们把项目拷贝给别人的时候不需要拷贝插件，只需要把项目文件、package.json 和 gulpfile.js 拷贝过去就可以，接收人 cd 到项目文件目录直接输入 npm install 即可安装上我们拷贝前安装的各种插件。 package.json 文件格式如下： { &quot;name&quot;: &quot;demo&quot;, // 项目名称 &quot;version&quot;: &quot;1.0.0&quot;, // 项目版本 &quot;description&quot;: &quot;test page&quot;, // 项目描述 &quot;main&quot;: &quot;example.js&quot;, // 入口文件 &quot;scripts&quot;: { // 运行脚本命令的 npm 命令行缩写 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;xiaoming&quot;, // 作者 &quot;license&quot;: &quot;ISC&quot; // 项目许可协议 } 可直接复制上述文本后修改，要注意的是 json 文件中不允许使用注释内容，所以如果是复制修改还需要将注释去掉。或在命令提示符下使用 npm init 命令来初始化自动生成 package.json 文件： $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help json` for definitive documentation on these fields and exactly what they do. Use `npm install &lt;pkg&gt; --save` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. name: (demo) version: (1.0.0) description: test page entry point: (example.js) test command: git repository: keywords: author: xiaoming license: (ISC) About to write to /Users/isaac/Documents/HTML5/projects/demo/package.json: { &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;test page&quot;, &quot;main&quot;: &quot;example.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;xiaoming&quot;, &quot;license&quot;: &quot;ISC&quot; } Is this ok? (yes) yes npm init 执行后会提示输入项目名称、版本、描述等信息，按提示输入即可，也可以留空。 2.6 本地安装 Gulp 及 Gulp 插件使用 npm install gulp --save-dev（安装了 cnpm 使用 cnpm install gulp --save-dev）在项目根目录本地安装 Gulp。 我们全局安装了 Gulp，又在项目目录中安装了本地 Gulp，主要因为全局安装 Gulp 是为了执行 Gulp 任务，本地安装 Gulp 则是为了调用 Gulp 插件的功能。 --save-dev 这个命令是将安装的插件信息写入 package.json 文件内的“devDependencies”属性内，执行后 package.json 文件内容变为： { &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;test page&quot;, &quot;main&quot;: &quot;example.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;xiaoming&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { // 项目依赖的插件 &quot;gulp&quot;: &quot;^3.9.1&quot; } } 本地安装 Gulp 后，继续安装常用的 Gulp 插件，本文安装了两个插件（JS 压缩插件与 CSS 压缩插件）来作为示例： $ npm install gulp-minify-css gulp-uglify --save-dev 3. 开始使用 Gulp3.1 建立 gulpfile.js 文件Gulp 需要一个文件作为它的主文件，在 Gulp 中这个文件叫做 gulpfile.js。 新建一个文件名为 gulpfile.js 的文件，然后放到项目目录中。然后在 gulpfile.js 文件中定义任务。 下面是一个最简单的 gulpfile.js 文件内容示例，它定义了一个默认的任务： var gulp = require(&quot;gulp&quot;); gulp.task(&quot;default&quot;, function(){ console.log(&quot;hello&quot;); }); 3.2 gulp.task() 方法gulp.task() 方法的主要是用来定义任务，其语法结构如下： gulp.task(name[, deps], fn) 参数 name 为任务名称。 deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。 fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 var minifyCss = require(&quot;gulp-minify-css&quot;); gulp.task(&quot;minify-css&quot;, function(){ gulp.src(&quot;css/*.css&quot;) .pipe(minifyCss({ advanced:false, // 是否开启高级优化（合并选择器等） compatibility:&quot;ie7&quot;, // 启用兼容模式；&apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式 keepBreaks:false, // 是否保留换行 keepSpecialComments:&quot;*&quot; // 保留所有特殊前缀，如果不加这个参数，有可能将会删除你的部分前缀 })) .pipe(gulp.dest(&quot;dist&quot;)); }); 上例中创建一个 CSS 压缩的任务，使用 gulp-minify-css 插件（现在 gulp-minify-css 已被废弃掉了，使用 gulp-clean-css 代替，用法基本一致）。要执行该任务，可使用任务名称来执行，使用： $ gulp minify-css 再创建一个 js 压缩的任务，使用 gulp-uglify： var uglify = require(&quot;gulp-uglify&quot;); gulp.task(&quot;uglify&quot;, function(){ gulp.src([&quot;js/*.js&quot;, &quot;!js/*.min.js&quot;]) .pipe(uglify({ mangle:true, // 是否修改变量名 compress:true // 是否完全压缩 })) .pipe(gulp.dest(&quot;dist/js&quot;)); }); 执行 JS 压缩任务： $ gulp uglify 当然不跟任务名称，也可以使用 gulp 命令直接执行任务，默认执行的是名称为 “default” 的任务。 我们可以将所有任务都放到 “default” 任务中： gulp.task(&quot;default&quot;, [&quot;minify-css&quot;, &quot;uglify&quot;]); 执行： $ gulp 将会调用 default 任务里的所有任务 [“minify-css”, “uglify”]。 3.3 gulp.src() 方法gulp.src() 方法是用来获取流的，这个流里的内容不是原始的文件流，而是一个虚拟文件对象流，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这暂时不用去深入理解，只需简单的理解可以用这个方法来读取需要操作的文件即可。语法结构如下： gulp.src(globs[, options]) 参数 globs 是文件匹配模式（类似正则表达式），用来匹配文件路径（包括文件名），当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。 options 为可选参数，通常不需要用到。 globs 文件匹配模式说明： * 匹配文件路径中的0个或多个字符 ** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其它东西，如果出现在末尾，也能匹配文件 ? 匹配文件路径中的一个字符 [...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法 !(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于 js 正则中的(pattern|pattern|pattern)? +(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于 js 正则中的(pattern|pattern|pattern)+ *(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于 js 正则中的(pattern|pattern|pattern)* @(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于 js 正则中的(pattern|pattern|pattern) gulp.src(&quot;css/*.css&quot;) 表示匹配 css 文件夹下所有后缀为 .css 的文件。 3.4 gulp.dest() 方法gulp.dest() 方法是用来写文件的，可以通过管道传输。语法结构为： gulp.dest(path[, options]) 参数 path 为写入文件的路径，如果文件路径不存在，会自动创建。 .pipe(gulp.dest(&quot;dist&quot;)) 表示将生成的文件写入 dist 目录中。 Gulp 的使用流程一般是：先通过 gulp.src() 方法获取到我们想要处理的文件流，然后把文件流通过 pipe() 方法导入到 gulp 的插件中，最后把经过插件处理后的流再通过 pipe() 方法导入到 gulp.dest() 中，gulp.dest() 方法则把流中的内容写入到文件中。 我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的。 3.5 gulp.watch() 方法gulp.watch 方法是用来监视文件修改的，语法结构为： gulp.watch(glob [, opts], tasks) // 或 gulp.watch(glob [, opts, cb]) glob 表示要监视的文件匹配模式说明，通常是字符串或数组的结构；opts 参数较少使用；tasks 表示当文件发生变化时要执行的任务，该任务是通过 gulp.task() 添加的，参数数据类型为数组类型；cb 表示回调函数，会在每次改变时都被调用到。 使用 tasks 参数示例： var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); watcher.on(&apos;change&apos;, function(event) { console.log(&apos;文件路径：&apos; + event.path + &apos;，类型：&apos; + event.type); }); 也可以使用回调函数： gulp.watch(&apos;js/**/*.js&apos;, function(event) { console.log(&apos;文件路径：&apos; + event.path + &apos;，类型：&apos; + event.type); }); 回调函数会传递 event 参数来描述所作的改变，该 event 对象有 type 和 path 两个属性。type 描述发生改变的类型，包括：added、changed、deleted 和 renamed；path 描述触发事件的文件路径。 4. 常用 Gulp 插件除了 CSS 与 JS 压缩的插件外，还有其它很多常用到的 Gulp 插件，下面列举一二。 4.1 html 文件压缩gulp-htmlmin： $ npm install gulp-htmlmin --save-dev 使用 gulp-minify-html 压缩 html 文件： var gulp = require(&apos;gulp&apos;), minifyHtml = require(&quot;gulp-htmlmin&quot;); gulp.task(&apos;minify-html&apos;, function(){ gulp.src(&apos;**/*.html&apos;) // 要压缩的html文件 .pipe(minifyHtml({collapseWhitespace: true})) //压缩 .pipe(gulp.dest(&apos;dist/html&apos;)); }); 4.2 重命名gulp-rename： $ npm install gulp-rename --save-dev 默认情况下，使用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用 gulp-rename 插件来改变文件流中的文件名： var gulp = require(&apos;gulp&apos;), rename = require(&apos;gulp-rename&apos;), uglify = require(&quot;gulp-uglify&quot;); gulp.task(&apos;rename&apos;, function(){ gulp.src(&apos;js/tools.js&apos;) .pipe(uglify()) // 压缩 js .pipe(rename(&apos;tools.min.js&apos;)) // 将 tools.js 重命名为 tools.min.js .pipe(gulp.dest(&apos;js&apos;)); }); 4.3 文件合并gulp-concat： $npm install gulp-concat --save-dev gulp-concat 可用来把多个文件合并为一个文件，我们可以用它来合并 JS 或 CSS 文件等，这样就能减少页面的 http 请求数了： var gulp = require(&apos;gulp&apos;), concat = require(&quot;gulp-concat&quot;); gulp.task(&apos;concat&apos;, function () { gulp.src(&apos;css/*.css&apos;) //要合并的文件 .pipe(concat(&apos;style.css&apos;)) // 合并匹配到的 CSS 文件为 &quot;all.css&quot; .pipe(gulp.dest(&apos;dist/css&apos;)); }); 4.4 SASS 编译gulp-sass： $ npm install gulp-sass --save-dev 编译 sass 文件： var gulp = require(&apos;gulp&apos;), sass = require(&quot;gulp-sass&quot;); gulp.task(&quot;sass&quot;, function(){ gulp.src(&quot;scss/*.scss&quot;) .pipe(sass()) // 编译 sass .pipe(minifyCss({ // 压缩 CSS advanced:true, compatibility:&quot;ie7&quot;, keepBreaks:false, keepSpecialComments:&quot;*&quot; })) .pipe(gulp.dest(&quot;dist/css&quot;)); }); gulp-sass 是调用 node-sass 来完成编译过程，有 node.js 环境就够了，但有的时候可能在安装 node-sass 过程中出错，只需要重新安装即可。 4.5 自动刷新gulp-livereload： $ npm install gulp-livereload --save-dev 当代码发生修改变化时，它可以帮我们自动刷新页面，推荐最好配合谷歌浏览器来使用，且要安装 livereload chrome extension 扩展插件。 var gulp = require(&quot;gulp&quot;), livereload = require(&quot;gulp-livereload&quot;); gulp.task(&quot;sass&quot;, function(){ gulp.src(&quot;scss/*.scss&quot;) .pipe(sass()) .pipe(minifyCss({ advanced:true, compatibility:&quot;ie7&quot;, keepBreaks:false, keepSpecialComments:&quot;*&quot; })) .pipe(gulp.dest(&quot;dist/css&quot;)) .pipe(livereload()); }); gulp.task(&apos;watch&apos;, function() { livereload.listen(); //要在这里调用listen()方法 gulp.watch(&quot;scss/*.scss&quot;, [&apos;sass&apos;]); }); 执行： $ gulp watch 这样就可以实时刷新修改的 CSS 内容了。 4.6 自动处理浏览器前缀gulp-autoprefixer： $ npm install gulp-autoprefixer --save-dev 使用 gulp-autoprefixer 根据设置浏览器版本自动处理浏览器前缀，使用它我们可以很潇洒地写代码，不必考虑各浏览器兼容前缀。 var autoprefixer = require(&apos;gulp-autoprefixer&apos;); gulp.task(&apos;autoFx&apos;, function () { gulp.src(&apos;css/style.css&apos;) .pipe(autoprefixer({ browsers: [&apos;last 2 versions&apos;, &apos;Android &gt;= 4.0&apos;], cascade: true, // 是否美化属性值 remove:true // 是否去掉不必要的前缀 })) .pipe(gulp.dest(&apos;dist/css&apos;)); }); browsers 指明浏览器信息，详情参见 browsers 参数详解。","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://zhanhongzj.github.io/tags/gulp/"},{"name":"工具","slug":"工具","permalink":"http://zhanhongzj.github.io/tags/工具/"}]},{"title":"JavaScript 面向对象之继承","slug":"js-中的继承","date":"2016-12-25T13:20:54.000Z","updated":"2017-08-02T12:36:36.385Z","comments":true,"path":"2016/12/25/js-中的继承/","link":"","permalink":"http://zhanhongzj.github.io/2016/12/25/js-中的继承/","excerpt":"","text":"1. 概述JavaScript 是一门非常灵活的语言，对于同一个问题的解决，往往有多种方法来实现。 继承是面向对象特性之一，它实现了代码的复用性与可维护性，可缩短开发周期，降低开发成本。继承易于维护管理，它避免了在一般类和特殊类之间共同特征的重复描述。 比如学生（一般类）具有学号、姓名、年龄、性别的特征，小学生、大学生（特殊类）都是学生，也都具备学生的特征，这时，我们就可以让小学生、大学生继承自学生，重用在学生描述部分的信息。 JavaScript 也可使用继承实现代码复用，在很多资料中对 JavaScript 的继承细致的分了许多种类与实现的方式，但无外乎两种方式：对象冒充、原型继承。本文介绍这两种实现继承的方式。 2. 对象冒充2.1 普通对象冒充对象冒充的实现方式是：让父类的构造函数成为子类的方法，然后调用子类的方法，使用 this 的特性为属性与方法赋值。 &lt;script type=&quot;text/javascript&quot;&gt; function Car(type, price) { this.type = type; this.price = price; this.show = function(){ return &quot;info : type = &quot; + this.type + &quot;, price = &quot; + this.price; }; } function Bus(type, price, capacity) { this.parent = Car; this.parent(type, price); delete this.parent; this.capacity = capacity; this.showInfo = function() { return this.show() + &quot;, capacity = &quot; + this.capacity; } } var bus = new Bus(&quot;ZK6809DX&quot;, 5000000, &quot;41人&quot;); console.log(bus.showInfo()); &lt;/script&gt; 有汽车对象，具有型号、价格的特征，客车是汽车，也有型号、价格的特征，当然它也有自己独立的特征：载客量。我让客车继承汽车，在 Bus 构造函数中，先设置this.parent = Car;将 parent 属性指向 Car 构造函数，表示即将复用 Car 函数中的内容。 this.parent(type, price); 执行后，实际调用到 Car 函数，在 Car 函数中有 this 关键字的使用。this 表示的是调用函数时刻的对象，Car 是在 Bus 中被this调用，即 Car 函数中的 this 指向 Bus 函数中的 this 对象。 当使用 new 调用 Bus 构造函数时，Bus 函数中的 this 指向 new 创建出来的 Bus 对象，所以this.parent(type, price);相当于是为 Bus 对象设置了 type、price、show 的属性。 这种继承的方式实际上是灵活使用了函数中 this 关键字，根据 this 所指代的对象来动态为所创建对象属性赋值。这就是对象冒充的方式实现继承。 2.2 call() 方法call() 语法： fun.call(thisArg[, arg1[, arg2[, ...]]]) call() 方法的作用是调用 fun 函数时，将 fun 函数中的 this 指向 call() 方法的第一个参数 thisArg 所表示的对象。非严格模式下，thisArg 如果为 null 或 undefined ，fun 中的 this 值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象。 [, arg1[, arg2[, ...]]] 为可选参数，表示在调用 fun 函数时所需要的参数列表。 &lt;script type=&quot;text/javascript&quot;&gt; function Car(type, price) { this.type = type; this.price = price; this.show = function(){ return &quot;info : type = &quot; + this.type + &quot;, price = &quot; + this.price; }; } function Bus(capacity) { this.capacity = capacity; this.showInfo = function() { return this.show() + &quot;, capacity = &quot; + this.capacity; } } var bus = new Bus(&quot;41人&quot;); Car.call(bus, &quot;ZK6809DX&quot;, 5000000); console.log(bus.showInfo()); &lt;/script&gt; Car.call(bus, &quot;ZK6809DX&quot;, 5000000); 调用 Car() 函数时，将函数中 this 指向 bus 对象，为 bus 对象添加 type、price、show 的属性。这同样是对象冒充的情况。 2.3 apply() 方法apply() 语法： fun.apply(thisArg[, argsArray]) 该方法和 call() 方法类似，不同之处在于 apply() 方法的第二个参数为数组或类数组对象。 &lt;script type=&quot;text/javascript&quot;&gt; function Car(type, price) { this.type = type; this.price = price; this.show = function(){ return &quot;info : type = &quot; + this.type + &quot;, price = &quot; + this.price; }; } function Bus(capacity) { this.capacity = capacity; this.showInfo = function() { return this.show() + &quot;, capacity = &quot; + this.capacity; } } var bus = new Bus(&quot;41人&quot;); Car.apply(bus, [&quot;ZK6809DX&quot;, 5000000]); console.log(bus.showInfo()); &lt;/script&gt; 其实仅将 2.2 例中的Car.call(bus, &quot;ZK6809DX&quot;, 5000000);修改为Car.apply(bus, [&quot;ZK6809DX&quot;, 5000000]);即可，这也是对象冒充方式。 2.4 说明使用对象冒充方式来实现继承也就这么回事，如果要实现多继承，重复类似过程即可。但在实际使用过程中，我们也不会大量使用对象冒充的方式来实现继承。 对象通常由属性与方法共同作用，在创建不同对象时，对象的属性拥有各自的私有值，便对象的方法一般是操作属性变量罢了，每个对象没必要各自都拥有一份该函数的副本，只需要将函数共享即可，这便会使用到 prototype 了。 上述示例中，为实现性能优化，通常我们会将方法放置在 prototype 中供实例对象共享，如： function Car(type, price) { this.type = type; this.price = price; } Car.prototype.show = function(){ return &quot;info : type = &quot; + this.type + &quot;, price = &quot; + this.price; }; 这时要通过对象冒充来实现继承 prototype 域中的属性方法就不行了。 3. 原型继承原型继承是利用 prototype 来达到继承的目的。 3.1 一句话继承&lt;script type=&quot;text/javascript&quot;&gt; function Student() { this.hobbies = []; } Student.prototype.introduce = function(){ return &quot;大家好，我叫 &quot; + this.name + &quot;，今年 &quot; + this.age + &quot; 岁，我的兴趣爱好有：&quot; + this.hobbies; } function Pupil(stuNo, name, age) { this.stuNo = stuNo; this.name = name; this.age = age; } Pupil.prototype = new Student(); // 实现继承 var pupil = new Pupil(&quot;s001&quot;, &quot;小明&quot;, 18); console.log(pupil.introduce()); &lt;/script&gt; Pupil.prototype = new Student(); 这条语句实现了 Pupil 继承自 Student 的操作。 通过 new Pupil() 创建了一个对象，该对象的隐式属性 __proto__ 指向了 Pupil 构造函数的显示属性 prototype，而 Pupil 的 prototype 指向了新创建的 Student 对象。则在 pupil 对象的原型链中可访问到 Student 原型中的方法 introduce，也可使用到 Student 构造函数中创建出来的 hobbies 属性。 3.2 混合模式继承3.1 中的继承也还存在一些问题，例如： &lt;script type=&quot;text/javascript&quot;&gt; function Student() { this.hobbies = []; } Student.prototype.introduce = function(){ return &quot;大家好，我叫 &quot; + this.name + &quot;，今年 &quot; + this.age + &quot; 岁，我的兴趣爱好有：&quot; + this.hobbies; } function Pupil(stuNo, name, age) { this.stuNo = stuNo; this.name = name; this.age = age; } Pupil.prototype = new Student(); // 实现继承 var pupil = new Pupil(&quot;s001&quot;, &quot;小明&quot;, 18); pupil.hobbies.push(&quot;吃饭&quot;, &quot;睡觉&quot;); console.log(pupil.introduce()); var another = new Pupil(&quot;s002&quot;, &quot;小红&quot;, 16); another.hobbies.push(&quot;打豆豆&quot;); console.log(another.introduce()); console.log(&quot;再次打印 pupil 对象信息：&quot; + pupil.introduce()); &lt;/script&gt; 创建第一个对象后，为其兴趣爱好添加两个：“吃饭、睡觉”，创建第二个对象后，仅为其兴趣爱好添加了一个“打豆豆”，但最终执行结果发现，another 对象的兴趣爱好有三个：“吃饭、睡觉、打豆豆”，而再次打印第一个对象 pupil 后发现，其兴趣爱好也变为三个。 造成这个问题的最主要原因是 Pupil 的所有对象都共享原型链中的 hobbies 属性，一旦有一个对象对 hobbies 作出修改，其它对象也会受到影响。显然这样是不太合适的，修改如下： &lt;script type=&quot;text/javascript&quot;&gt; function Student() { this.hobbies = []; } Student.prototype.introduce = function(){ return &quot;大家好，我叫 &quot; + this.name + &quot;，今年 &quot; + this.age + &quot; 岁，我的兴趣爱好有：&quot; + this.hobbies; } function Pupil(stuNo, name, age) { this.stuNo = stuNo; this.name = name; this.age = age; } // 实现继承 function Super(){} Super.prototype = Student.prototype; Pupil.prototype = new Super(); var pupil = new Pupil(&quot;s001&quot;, &quot;小明&quot;, 18); console.log(pupil.introduce()); &lt;/script&gt; 执行结果却发现，无法访问到 hobbies 这个属性。why？ 分析一下：在 pupil 对象的原型链中，由于并未像 3.1 一样去创建 Student 的对象，所以也就不存在 hobbies 这个属性，所以打印时会显示兴趣爱好为：undefined。 那又如何解决兴趣爱好这个属性的使用呢，对于每个学生来说，兴趣爱好应该算是学生的一个私有的属性，不同的学生兴趣爱好取值会不一样，可以将兴趣爱好这个属性重新处理： function Student(hobbies) { this.hobbies = hobbies || []; } function Pupil(stuNo, name, age, hobbies) { Student.call(this, hobbies); this.stuNo = stuNo; this.name = name; this.age = age; } 可将兴趣爱好继续按照第 2 节中对象冒充的方式作继承处理，那这样属性与方法的继承就分别进行，这也就是典型的采用混合模式实现的继承：对象冒充实现私有属性继承、原型实现共享属性继承。完整示例： &lt;script type=&quot;text/javascript&quot;&gt; function Student(hobbies) { this.hobbies = hobbies || []; } Student.prototype.introduce = function(){ return &quot;大家好，我叫 &quot; + this.name + &quot;，今年 &quot; + this.age + &quot; 岁，我的兴趣爱好有：&quot; + this.hobbies; } function Pupil(stuNo, name, age, hobbies) { Student.call(this, hobbies); this.stuNo = stuNo; this.name = name; this.age = age; } // 实现继承 function Super(){} Super.prototype = Student.prototype; Pupil.prototype = new Super(); var pupil = new Pupil(&quot;s001&quot;, &quot;小明&quot;, 18); pupil.hobbies.push(&quot;吃饭&quot;, &quot;睡觉&quot;); console.log(pupil.introduce()); var another = new Pupil(&quot;s002&quot;, &quot;小红&quot;, 16); another.hobbies.push(&quot;打豆豆&quot;); console.log(another.introduce()); console.log(&quot;再次打印 pupil 对象信息：&quot; + pupil.introduce()); &lt;/script&gt; 4. 拷贝式继承还有一种继承方式也是比较典型的继承：拷贝继承。 &lt;script type=&quot;text/javascript&quot;&gt; function Student(hobbies) { this.hobbies = hobbies || []; } Student.prototype.introduce = function(){ return &quot;大家好，我叫 &quot; + this.name + &quot;，今年 &quot; + this.age + &quot; 岁，我的兴趣爱好有：&quot; + this.hobbies; } function Pupil(stuNo, name, age, hobbies) { Student.call(this, hobbies); this.stuNo = stuNo; this.name = name; this.age = age; } // 实现继承:拷贝 Student.prototype 的 // 所有属性到 Pupil.prototype 中 for(var attr in Student.prototype){ Pupil.prototype[attr] = Student.prototype[attr]; } var pupil = new Pupil(&quot;s001&quot;, &quot;小明&quot;, 18); pupil.hobbies.push(&quot;吃饭&quot;, &quot;睡觉&quot;); console.log(pupil.introduce()); var another = new Pupil(&quot;s002&quot;, &quot;小红&quot;, 16); another.hobbies.push(&quot;打豆豆&quot;); console.log(another.introduce()); console.log(&quot;再次打印 pupil 对象信息：&quot; + pupil.introduce()); &lt;/script&gt; 将 Student.prototype 中的所有可枚举属性遍历后一一拷贝到 Pupil.prototype 中。实际上就是利用代码的方式来实现的 ctrl+c/ctrl+v 功能。","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhanhongzj.github.io/tags/JS/"}]},{"title":"JavaScript 对象初识","slug":"对象的创建","date":"2016-12-22T06:34:42.000Z","updated":"2017-08-02T12:39:41.561Z","comments":true,"path":"2016/12/22/对象的创建/","link":"","permalink":"http://zhanhongzj.github.io/2016/12/22/对象的创建/","excerpt":"","text":"1. 概述在 JavaScript 中，数据类型分为：number、string、boolean、undefined、null、object，其中 number、string、boolean、undefined、null 也称为基本数据类型，而 object 称为引用数据类型。 之所以 object 和其它数据类型不同，是因为对象是一种复合值，它将若干值以 key-value 键值对的形式聚合在一起。我们可以将对象看作是一系列无序的数据集合，通过 key 关键字可以访问到其关联的 value 值。 2. 对象创建对象创建有三种方式：对象直接量方式、new 调用构造函数方式与 Object.create() 方式。 2.1 对象直接量直接量也称为字面量，对象直接量由若干 key-value 键值对组成映射表，key 与 value 间使用冒号（:）分隔，键值对间会用逗号（,）分隔，将所有 key-value 键值对包裹在花括号（{}）之间： var student = { name : &quot;张三&quot;, age : 18, sex : &quot;男&quot; }; 对象的所有键名都是字符串，所以在 JavaScript 中，键名可使用引号（单引号、双引号均可），也可不使用引号，不使用引号会自动转为字符串。上边的对象也等价于： var student = { &quot;name&quot; : &quot;张三&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;男&quot; }; 对象的所有键值对也叫做属性，键名就是属性名，键值就是属性值。键值可以是任意数据类型，即键值也可以是函数（function），当键值为函数时，我们通常就将这个属性称为“方法”。 var student = { name : &quot;张三&quot;, age : 18, sex : &quot;男&quot;, show : function(){ console.log(&quot;这是一个学生对象...&quot;); } }; ES5 标准中，允许对象直接量最后一个属性后有一个逗号，但如果是旧版本的浏览器，不支持 ES5 标准，则会提示错误。 2.2 new 构造函数我们可以像创建数组对象、日期时间对象一样，通过 new 调用构造函数来创建普通的对象： var student = new Object(); 对象创建后，通过点运算符或索引方式为对象添加属性： student.name = &quot;张三&quot;; student[&quot;age&quot;] = 18; 通过 new Object() 创建的一个空对象，也可直接写成：new Object 省略小括号的编写。 也可以在 new 创建对象时传递参数，如果传递参数是一个对象，则直接返回参数对象： var obj = {name:&quot;张三&quot;, age:18}; var stu = new Object(obj); console.log(obj === stu); // true 如果传递参数是基本类型的值，则返回包装对象： var obj1 = new Object(1.3); // Number {} var obj2 = new Object(&quot;test&quot;); // String {0: &quot;t&quot;, 1: &quot;e&quot;, 2: &quot;s&quot;, 3: &quot;t&quot;, length: 4} var obj3 = new Object(true); // Boolean {} var obj4 = new Object(undefined); // {} var obj5 = new Object(null); // {} 注意，传递 undefined 与 null 会返回空对象。 当以非构造函数形式被调用时，Object 等同于 new Object()，即我们通常使用 Object() 来实现数据类型的转换，将其它类型转换为对象类型： var obj1 = Object(1); var obj2 = Object(true); 2.3 Object.create()ES5 新特性中定义了名为 Object.create() 的方法，用来创建对象。 语法： Object.create(proto, [ propertiesObject ]) proto 参数是作为新创建对象的原型，propertiesObject 是可选参数，用来对对象的属性进行描述： var sexValue; var stu = Object.create(Object.prototype, { name : { value: &quot;张三&quot;, writable: true, configurable:true, enumerable: true }, age : { get : function(){return 18}, configurable:true, enumerable: true }, sex : { get : function(){return sexValue}, set : function(newSexValue){sexValue = newSexValue;}, configurable:true, enumerable: false } }); 有关对象属性描述，可见《ES5 新特性》说明。 3. 删除对象属性delete 命令可用于删除对象属性，返回是否删除成功： var obj = {name:&quot;lily&quot;, age:18, sex:&quot;female&quot;}; console.log(Object.keys(obj)); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] console.log(delete obj.sex); // true console.log(Object.keys(obj)); // [&quot;name&quot;, &quot;age&quot;] console.log(obj.sex); // undefined 注意，删除一个不存在的属性也会返回 true ： console.log(delete obj.address); // true 所以不能仅通过返回值的 true 或 false 就判断对象属性存在与不存在，只能保证删除后再次读取该属性值返回 undefined。 但下边的情况 delete 会返回 false： var stu = Object.create(Object.prototype, { name : { value: &quot;张三&quot;, writable: true, configurable:false, enumerable: true } }); console.log(delete stu.name); // false console.log(stu.name); // 张三 4. in 运算符in 运算符用于检查对象是否包含某个属性（注意：检查的是键名，不是键值），如果包含就返回 true，否则返回 false。 var obj = {name:&quot;lily&quot;, age:18, sex:&quot;female&quot;}; console.log(&quot;age&quot; in obj); // true console.log(&quot;address&quot; in obj); // false in 运算符的一个问题是，它不能识别对象继承的属性： console.log(&quot;toString&quot; in obj); // true toString 方法不是对象 obj 自身的属性，而是继承的属性，如果要判断是否 obj 自身的属性，可以使用hasOwnProperty 方法： console.log(obj.hasOwnProperty(&quot;toString&quot;)); // false 5. for .. infor…in 循环可用来遍历一个对象的全部属性： var obj = {name:&quot;lily&quot;, age:18, sex:&quot;female&quot;}; for (var attr in obj) { console.log(attr, obj[attr]); } 打印结果： name – &quot;lily&quot; age – 18 sex – &quot;female&quot; for…in 循环有两个使用注意点： 遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性 不仅遍历对象自身的属性，还遍历继承的属性 示例： function Student(name, age){ this.name = name; this.age = age; } Student.prototype.show = function(){ console.log(&quot;学生信息...&quot;); } var obj = new Student(&quot;lily&quot;, 18); var stu = Object.create(obj, { address : { value : &quot;成都&quot;, enumerable : true }, sex : { value : &quot;女&quot; } }); for (var attr in stu) { console.log(attr, stu[attr]); } 打印结果： address – &quot;成都&quot; name – &quot;lily&quot; age – 18 show – function (){ console.log(&quot;学生信息...&quot;); } 参考 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object http://javascript.ruanyifeng.com/grammar/object.html","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhanhongzj.github.io/tags/JS/"}]},{"title":"JavaScript 中的运动","slug":"js中的运动","date":"2016-12-20T15:00:45.000Z","updated":"2017-08-02T12:20:01.943Z","comments":true,"path":"2016/12/20/js中的运动/","link":"","permalink":"http://zhanhongzj.github.io/2016/12/20/js中的运动/","excerpt":"","text":"1. 概述JavaScript 中的运动效果使用非常多，比如页面中常见的轮播图效果、图片淡入淡出效果、广告图片展开隐藏效果等等，都涉及到运动。 我们可以使用各种运动框架去完成运动效果，当然也可以先自己来实现一套运动框架。 2. 算法实现2.1 基本的水平匀速运动效果在实现元素水平匀速运动前，选将页面元素定位方式设置为 “absolute” 绝对定位，我们在 JS 代码中将元素 CSS 属性 left 值定时修改即可。要实现实时修改操作，又需要使用到定时器来完成功能，这里使用 setInterval() 方法： &lt;script type=&quot;text/javascript&quot;&gt; // 根据 id 查找页面元素 function $(id) { return document.getElementById(id); } // 查找 element 元素 attr CSS 属性值 function css (element, attr) { return element.currentStyle ? element.currentStyle[attr] : getComputedStyle(element, null)[attr]; } var _left = parseFloat(css($(&quot;box&quot;), &quot;left&quot;)) || 0, // 初始水平定位 speed = 5; // 水平运动速度 // 启动定时器，运动 var timer = setInterval(function(){ _left += speed; if (_left &gt;= 200){ // 运动到达目标终点，取消定时器 _left = 200; clearInterval(timer); } // 设置定位位置 $(&quot;box&quot;).style.left = _left + &quot;px&quot;; }, 30); &lt;/script&gt; 以上代码只是实现水平向右运动，如果要实现水平向左运动呢？ var _left = parseFloat(css($(&quot;box&quot;), &quot;left&quot;)) || 0, // 初始定位 speed = -5; // 水平速度 // 启动定时器，运动 var timer = setInterval(function(){ _left += speed; if (_left &lt;= 0){ // 运动到达目标终点，取消定时器 _left = 0; clearInterval(timer); } // 设置定位位置 $(&quot;#box&quot;).style.left = _left + &quot;px&quot;; }, 30); 只需更改速度 speed 变量值，及将终点条件判断改为 _left &lt;= 0 后的逻辑运算，其它部分不用修改。 2.2 适用不同属性的运动效果那如果要实现垂直方向的运动呢，其操作和水平方向运动相似，垂直向下运动： var _top = parseFloat(css($(&quot;box&quot;), &quot;top&quot;)) || 0, // 初始定位 speed = 5; // 垂直速度 // 启动定时器，运动 var timer = setInterval(function(){ _top += speed; if (_top &gt;= 200){ // 运动到达目标终点，取消定时器 _top = 200; clearInterval(timer); } // 设置定位位置 $(&quot;#box&quot;).style.left = _top + &quot;px&quot;; }, 30); 垂直向上运动： var _top = parseFloat(css($(&quot;box&quot;), &quot;top&quot;)) || 0, // 初始定位 speed = -5; // 垂直速度 // 启动定时器，运动 var timer = setInterval(function(){ _top += speed; if (_top &lt;= 0){ // 运动到达目标终点，取消定时器 _top = 0; clearInterval(timer); } // 设置定位位置 $(&quot;#box&quot;).style.left = _top + &quot;px&quot;; }, 30); 那如果要修改元素的宽度 width，高度 height 这些属性使其运动呢，和水平/垂直运动也是类似的，但每次再去将上述代码写一次显示非常冗余。这时，我们可以使用函数封装，来实现代码的重用： // attr:运动属性 function animate (attr) { var current = parseFloat(css($(&quot;box&quot;), attr)) || 0, // 初始定位 speed = 5; // 速度 // 启动定时器，运动 var timer = setInterval(function(){ current += speed; if (current &gt;= 200){ // 运动到达目标终点，取消定时器 current = 200; clearInterval(timer); } // 设置元素CSS属性 $(&quot;#box&quot;).style[attr] = current + &quot;px&quot;; }, 30); } 这样就可以适用于如width、height、left、right 属性的运动了，但执行后又发现，上述函数的功能要实现，必须是初始属性值在小于 200 时才能实现功能，那如果初始属性值大于 200 则不会有动画效果，而直接会将元素指定 CSS 属性值设置为 “200px”。 继续优化： // attr:运动属性 // target:属性运动终值 function animate (attr, target) { var current = parseFloat(css($(&quot;box&quot;), attr)) || 0, // 初始定位 speed = target &gt; current ? 5 : -5; // 根据终值与初始值计算速度 // 启动定时器，运动 var timer = setInterval(function(){ current += speed; // 计算运动当前值 if (speed &gt; 0 &amp;&amp; current &gt;= target || speed &lt; 0 &amp;&amp; current &lt;= target){ // 运动到达目标终点，取消定时器 current = target; clearInterval(timer); } // 设置元素CSS属性 $(&quot;#box&quot;).style[attr] = current + &quot;px&quot;; }, 30); } 将运动的属性与终值都作为参数传递到 animate() 函数内部，在函数内根据目标终值与运动前初始值大小关系决定运动速度的正负情况。运动到达目标终值后，停止定时器，运动效果完成。 2.3 页面多元素运动上面所封装的函数也仅适用于页面上固定的 id 为 box 的元素，如果页面上有 10 个元素需要设置运动动画效果，那它就不适用了。 优化： // element:待添加运动动画的元素 // attr:运动属性 // target:属性运动终值 function animate (element, attr, target) { var current = parseFloat(css(element, attr)) || 0, // 初始定位 speed = target &gt; current ? 5 : -5; // 根据终值与初始值计算速度 // 启动定时器，运动 var timer = setInterval(function(){ current += speed; // 计算运动当前值 if (speed &gt; 0 &amp;&amp; current &gt;= target || speed &lt; 0 &amp;&amp; current &lt;= target){ // 运动到达目标终点，取消定时器 current = target; clearInterval(timer); } // 设置元素CSS属性 element.style[attr] = current + &quot;px&quot;; }, 30); } 将待添加运动动画的元素作为函数参数传递到函数体内部使用，这样，就可以根据传递的不同页面 DOM 元素去获取各自的指定属性初始值，设置各自属性的运动中值及终值。 2.4 定时器问题2.3 节中封装的函数，如果某一个 DOM 元素调用它执行一次完整的运动动画效果，可以顺利的执行起来。但在页面中实现如下按钮所示功能： &lt;button id=&quot;right&quot;&gt;将 #box 元素水平移动到 800 像素&lt;/button&gt; &lt;button id=&quot;left&quot;&gt;将 #box 元素水平移动到 100 像素&lt;/button&gt; JS 片段： $(&quot;right&quot;).onclick = function(){ animate($(&quot;box&quot;), &quot;left&quot;, 800); }; $(&quot;left&quot;).onclick = function(){ animate($(&quot;box&quot;), &quot;left&quot;, 100); }; 如果点击 #right 按钮等到 #box 元素完全移动到 800 像素位置后，再点击 #left 按钮让 #box 移动到 100 像素位置，能够顺利执行。但如果点击 #right 按钮后，在 #box 移动到中途（比如 450 像素位置）时，又点击 #left 按钮让元素移动到 100 像素位置，这时页面中 #box 元素就会出现运动抖动现象。 因为点击两个按钮时，都各自创建了一个定时器，来使 #box 的元素向自己指定的方向运动，而在定时器中操作的运动元素指向的是同一个 DOM 元素对象，所以向右运动的定时器起作用时，元素在页面定位位置靠右，向左定时器起作用时，元素在页面定位位置又变成靠左了。 要解决这个问题，可以设置当按下 #left 按钮时，取消 #right 按下时设置的定时器，在按下 #right 按钮时，取消 #left 按下时设置的定时器。这就意味着针对同一个元素操作的定时器应该使用同一个引用： // 定时器 id var timer = null; // element:运动元素 // attr:运动属性 // target:属性运动终值 function animate (element, attr, target) { // 先取消在 timer 中保存的定时器 clearInterval(timer); var current = parseFloat(css(element, attr)) || 0, // 初始定位 speed = target &gt; current ? 5 : -5; // 根据终值与初始值计算速度 // 启动定时器，运动 timer = setInterval(function(){ current += speed; // 计算运动当前值 if (speed &gt; 0 &amp;&amp; current &gt;= target || speed &lt; 0 &amp;&amp; current &lt;= target){ // 运动到达目标终点，取消定时器 current = target; clearInterval(timer); } // 设置元素CSS属性 element.style[attr] = current + &quot;px&quot;; }, 30); } 但如果页面中有多个元素要同时实现运动动画效果，使用上述函数后，最终的效果是页面中只能有一个元素表现动画效果，因为每个元素添加运动动画时，都会将其它元素上添加的运动动画定时器取消掉。那这样如果要实现多个元素同时添加上运动动画，是否要定义多个变量来保存定时器呢，在运动结束时又该如果取消设置的定时器呢。 为解决这个问题，我们将各元素上添加的运动动画定时器和元素本身绑定在一起，也就是说，为哪个元素添加运动动画效果，就直接以属性的方式将定时器 id 保存在该元素属性中，这样就可以解决多个元素各自运动定时器独立开的问题，也不用想办法去找怎么定义多个不同的变量，查找不同变量了。 修改如下： // element:运动元素 // attr:运动属性 // target:属性运动终值 function animate (element, attr, target) { // 先取消 element 本身已有的定时器，结束前一次运动动画 clearInterval(element.timer); var current = parseFloat(css(element, attr)) || 0, // 初始定位 speed = target &gt; current ? 5 : -5; // 根据终值与初始值计算速度 // 启动定时器，运动，将定时器 id 保存在当前元素的属性中 element.timer = setInterval(function(){ current += speed; // 计算运动当前值 if (speed &gt; 0 &amp;&amp; current &gt;= target || speed &lt; 0 &amp;&amp; current &lt;= target){ // 运动到达目标终点，取消定时器 current = target; clearInterval(timer); } // 设置元素CSS属性 element.style[attr] = current + &quot;px&quot;; }, 30); } 2.5 多属性运动问题上述封装都还只是针对的是某元素的单属性运动问题，如果元素有多个属性需要同时运动，比如一个元素需要同时在水平和垂直方向运动，继续修改： // element:运动元素 // options:存放各运动目标终值的对象，如：{top:200, width:300, left:100} function animate (element, options) { // 先取消 element 本身已有的定时器，结束前一次运动动画 clearInterval(element.timer); // 定义对象来保存各运动属性的初始值，速度 var current = {}, speed = {}; // 设置各运动属性初值、速度 for (var attr in options) { current[attr] = parseFloat(css(element, attr)) || 0; speed[attr] = options[attr] &gt; current[attr] ? 5 : -5; } // 启动定时器，运动，将定时器 id 保存在当前元素的属性中 element.timer = setInterval(function(){ var clear = true; // 标记是否应该关闭定时器，所有属性都运动到达目标终点才关闭 // 各属性计算运动当前值，设置运动当前值 for (var attr in options) { current[attr] += speed[attr]; if (speed[attr] &gt; 0 &amp;&amp; current[attr] &gt;= options[attr] || speed[attr] &lt; 0 &amp;&amp; current[attr] &lt;= options[attr]) { current[attr] = options[attr]; } // 设置元素 css 属性 element.style[attr] = current[attr] + &quot;px&quot;; // 计算是否应该关闭定时器 if (current[attr] !== options[attr]) { // 当前属性未运动到达目标终点 clear = false; } } // 所有属性运动到达目标终点，停止定时器 if (clear){ clearInterval(element.timer); } }, 30); } 至此，同一元素多属性运动问题算是基本解决了。如： animate($(&quot;box&quot;), {top:200, left:300, width:100, height:300}); 2.6 能够控制时间的单属性运动效果不管是封装的单属性运动动画，还是多属性运动动画，都还不支持时间控制，比如 3 秒完成从起始位置运动到达目标终点，或是 400 毫秒完成运动动画。我们还是先来看最简单的单属性控制时间的运动动画，仍以匀速运动为例介绍。 如果要使 #box 元素从页面中水平位置 100 像素处运动到 500 像素处，总耗时控制在 2 秒完成运动动画，我们来分析运动过程。 从水平位置 100 像素到 500 像素处，有 400 像素宽度的可运动区间，在这 400 像素运动区间内，如果控制 2 秒完成运动动画，我们可以计算一下单位时间的运动距离。在实现运动动画效果时，我们使用了 setInterval() 方法来周期性使元素每隔指定时间修改一次运动属性值的设置，而 setInterval() 计时单位为毫秒，将 2 秒换算为 2000 毫秒来处理。 可以求出 1 毫秒单位时间的运动距离：400 / 2000，即 运动区间宽度 / 总时间。那么，如果运动已经经过 1200 毫秒了，就可以计算出运动过的距离：1200 * 400 / 2000，即 已运动时间 * 运动区间宽度 / 总时间。如果要换算成水平方向元素的定位位置，则再加上元素运动前的初始水平定位位置即可：运动元素水平定位 = 已运动时间 * 运动区间宽度 / 总时间 + 运动前初始水平定位。 根据推导的公式，如果运动时间达到 2000 毫秒，则恰好到达运动目标终值。 由水平方向运动动画，可推广到其它属性，公式类似。代码表述如下： // element: 待添加运动动画元素 // speed: 设置运动总时间 // attr: 运动属性 // target: 运动终值 function animate(element, speed, attr, target) { clearInterval(element.timer); // 运动前初始位置 var start = parseFloat(css($(&quot;box&quot;), attr)) || 0; // 可运动区间范围 var origin = target - start; // 运动前先记录一下起始运动时间 var startTime = +new Date(); // 运动 element.timer = setInterval(function(){ // 计算运动耗时 var elapse = Math.min(+new Date() - startTime, speed); // 根据公式计算运动过程中属性值 var value = (elapse * origin / speed) + start; // 设置属性值 element.style[attr] = value + &quot;px&quot;; // 当运动到达指定时间，则停止定时器 if (elapse === speed) { clearInterval(element.timer); } }, 30); } 假如设置运动总时间控制为 100 毫秒，则理论上定时器 setInterval() 指定函数会在 30 毫秒、60 毫秒、90 毫秒和 120 毫秒时被调用（实际可能由于 event loop 机制有一定的时间延迟）。 我们发现，在运动到 100 毫秒时，并不会触发 setInterval() 第一个参数函数的执行，而是再继续运动 20 毫秒后才执行该函数，这就意味着在运动过程中，多余了 20 毫秒的运动时间，如果我们在计算运动过程值时使用 运动元素属性值 = 已运动时间 * 运动区间范围 / 总时间 + 运动前初始值 公式，则算出的属性值会超出目标终值的范围，显然这是不合适的。 虽然多运动了 20 毫秒的时间，但我们不能在超出运动目标终值后再继续运动，这样和运动需求相郣。也就是说，即使多运动了 20 毫秒时间，我们最终还是应该以运动 100 毫秒来计算运动属性值，使得能够正常在运动时到达运动目标。这也是 var elapse = Math.min(+new Date() - startTime, speed); 这条语句的主要作用。 2.7 能够控制时间的多属性运动同样将控制时间时的单属性运动扩展到多属性运动： // element:待实现运动动画的元素 // options: 对象，保存运动目标终值的对象 // speed: 控制运动时间，单位---毫秒 function animate(element, options, speed) { // 先取消当前元素上之前的运动动画 clearInterval(element.timer); // 保存各属性运动前的初始值 var start = {}; // 保存各属性运动的范围 var origin = {}; // 获取各运动初始的初始值 for (var attr in options) { start[attr] = parseFloat(css(element, attr)) || 0; origin[attr] = options[attr] - start[attr]; } // 记录运动起始时间 var startTime = +new Date(); // 启动定时器，实现运动动画 element.timer = setInterval(function(){ // 计算已运动时间 var elapsed = Math.min(+new Date() - startTime, speed); // 换算各属性当前次属性值 for (var attr in options) { // 计算当前遍历到的 attr 属性值 var value = elapsed * origin[attr] / speed + start[attr]; // 设置 element 元素CSS属性值 element.style[attr] = value + &quot;px&quot;; } // 判断是否停止定时器 if (elapsed === speed) { clearInterval(element.timer); } }, 30); } 步骤和单属性运动动画步骤基本一致，只是使用了 for-in 循环结构遍历了每个运动的属性，将各属性的初值、可运动范围都保存在了对象中，在设置运动值时使用到了这些值。 2.8 不透明度的处理如果需要有不透明度的渐变运动效果，那么将之前的函数继续改造一下： // element:待实现运动动画的元素 // options: 对象，保存运动目标终值的对象 // speed: 控制运动时间，单位---毫秒 function animate(element, options, speed) { // 先取消当前元素上之前的运动动画 clearInterval(element.timer); // 保存各属性运动前的初始值 var start = {}; // 保存各属性运动的范围 var origin = {}; // 获取各运动初始的初始值 for (var attr in options) { start[attr] = parseFloat(css(element, attr)) || attr === &quot;opacity&quot; ? 1 : 0; origin[attr] = options[attr] - start[attr]; } // 记录运动起始时间 var startTime = +new Date(); // 启动定时器，实现运动动画 element.timer = setInterval(function(){ // 计算已运动时间 var elapsed = Math.min(+new Date() - startTime, speed); // 换算各属性当前次属性值 for (var attr in options) { // 计算当前遍历到的 attr 属性值 var value = elapsed * origin[attr] / speed + start[attr]; // 设置 element 元素CSS属性值 element.style[attr] = value + (attr === &quot;opacity&quot; ? &quot;&quot; : &quot;px&quot;); // IE opacity if (attr === &quot;opacity&quot;) { element.style.filter = &quot;alpha(opacity=&quot;+ (value * 100) +&quot;)&quot;; } } // 判断是否停止定时器 if (elapsed === speed) { clearInterval(element.timer); } }, 30); } 因为 opacity 在 CSS 属性中是没有单位的，所以在设置时不需要添加 px 像素单位。IE 低版本浏览器中不支持 opacity 属性的使用，支持的是过滤器的使用，所以添加了一点关于 IE 中不透明度的处理。 2.9 完善及链接运动在调用 animate() 函数执行时，可以设置 speed 参数为可选参数，即如果不设置运动时间，可以默认 speed 为 400 毫秒的时间。 在运动动画执行结束后，如果还有后继需要继续执行的函数，可以继续传递后继执行函数。 修改如下： // element:待实现运动动画的元素 // options: 对象，保存运动目标终值的对象 // speed: 控制运动时间，单位---毫秒，可选参数，不选则默认 400 ms // fn : 运动动画结束后，继续执行的函数 function animate(element, options, speed, fn) { // 判断是否有传递时间参数 if (typeof speed === &quot;function&quot;){ // 未传递时间数字，在该参数中接收到函数引用 fn = speed; speed = 400; // 默认值 400 毫秒 } // 先取消当前元素上之前的运动动画 clearInterval(element.timer); // 保存各属性运动前的初始值 var start = {}; // 保存各属性运动的范围 var origin = {}; // 获取各运动初始的初始值 for (var attr in options) { start[attr] = parseFloat(css(element, attr)) || (attr === &quot;opacity&quot; ? 1 : 0); origin[attr] = options[attr] - start[attr]; } // 记录运动起始时间 var startTime = +new Date(); // 启动定时器，实现运动动画 element.timer = setInterval(function(){ // 计算已运动时间 var elapsed = Math.min(+new Date() - startTime, speed); // 换算各属性当前次属性值 for (var attr in options) { // 计算当前遍历到的 attr 属性值 var value = elapsed * origin[attr] / speed + start[attr]; // 设置 element 元素CSS属性值 element.style[attr] = value + (attr === &quot;opacity&quot; ? &quot;&quot; : &quot;px&quot;); // IE opacity if (attr === &quot;opacity&quot;) { element.style.filter = &quot;alpha(opacity=&quot;+ (value * 100) +&quot;)&quot;; } } // 判断是否停止定时器 if (elapsed === speed) { clearInterval(element.timer); // 判断，有要继续执行的函数，则调用 fn &amp;&amp; fn(); } }, 30); } 调用示例： animate($(&quot;box&quot;), {top:200}, 2000， function(){ animate($(&quot;box&quot;),{left:300}, 3000, function(){ animate($(&quot;box&quot;), {width:400}); }); }); 2.10 其它运动效果以上的封装都是针对匀速运动的封装，匀速运动也称线性运动，但实际开发中，可能也会遇到其它类型的运动效果，比如加速运动、减速运动、先加速后减速运动等。要实现其它类型的运动效果，更多的是在算法上的不同，就逻辑步骤上来说，和匀速运动基本一致。借鉴 Tween 算法来改进我的运动框架： // element:待实现运动动画的元素 // options: 对象，保存运动目标终值的对象 // speed: 控制运动时间，单位---毫秒，可选参数，不选则默认 400 ms // easing: 运动类型，可选参数，可取值有：linear、easeIn、easeOut、easeInOut，默认为 linear // fn : 运动动画结束后，继续执行的函数 function animate(element, options, speed, easing, fn) { // 判断是否有传递时间参数、运动类型参数 if (typeof speed === &quot;string&quot;){ // 未传递时间数字，该参数中接收到字符串，表示运动类型 fn = easing; easing = [&quot;linear&quot;, &quot;easeIn&quot;, &quot;easeOut&quot;, &quot;easeInOut&quot;].indexOf(speed) !== -1 ? speed : &quot;linear&quot;; speed = 400; } else if (typeof speed === &quot;function&quot;){ // 未传递时间数字，在该参数中接收到函数引用 fn = speed; easing = &quot;linear&quot;; // 默认运动类型为 “linear” speed = 400; } else if (typeof speed === &quot;undefined&quot;) { speed = 400; easing = &quot;linear&quot;; } else if (typeof easing === &quot;function&quot;) { // 未传递运动类型，该参数表示函数 fn = easing; easing = &quot;linear&quot;; // 默认运动类型为 “linear” } else if (typeof easing === &quot;undefined&quot;) { easing = &quot;linear&quot;; } // 确保 easing 在 linear、easeIn、easeOut、easeInOut 中取值 easing = [&quot;linear&quot;, &quot;easeIn&quot;, &quot;easeOut&quot;, &quot;easeInOut&quot;].indexOf(easing) !== -1 ? easing : &quot;linear&quot;; console.log(speed, easing, fn) // 先取消当前元素上之前的运动动画 clearInterval(element.timer); // 保存各属性运动前的初始值 var start = {}; // 保存各属性运动的范围 var origin = {}; // 获取各运动初始的初始值 for (var attr in options) { start[attr] = parseFloat(css(element, attr)) || (attr === &quot;opacity&quot; ? 1 : 0); origin[attr] = options[attr] - start[attr]; } // 记录运动起始时间 var startTime = +new Date(); // 启动定时器，实现运动动画 element.timer = setInterval(function(){ // 计算已运动时间 var elapsed = Math.min(+new Date() - startTime, speed); // 换算各属性当前次属性值 for (var attr in options) { var value; // 根据运动类型计算当前遍历到的 attr 属性值 switch(easing) { case &quot;linear&quot;: // 线性 value = elapsed * origin[attr] / speed + start[attr]; break; case &quot;easeIn&quot;: // 加速 value = origin[attr] * (elapsed /= speed) * elapsed + start[attr]; break; case &quot;easeOut&quot;: // 减速 value = -origin[attr] * (elapsed /= speed) * (elapsed - 2) + start[attr]; break; case &quot;easeInOut&quot;: // 加速减速 if ((elapsed /= speed / 2) &lt; 1) value = origin[attr] / 2 * elapsed * elapsed + start[attr]; else value = -origin[attr] / 2 * ((--elapsed) * (elapsed - 2) - 1) + start[attr]; break; } // 设置 element 元素CSS属性值 element.style[attr] = value + (attr === &quot;opacity&quot; ? &quot;&quot; : &quot;px&quot;); // IE opacity if (attr === &quot;opacity&quot;) { element.style.filter = &quot;alpha(opacity=&quot;+ (value * 100) +&quot;)&quot;; } } // 判断是否停止定时器 if (elapsed === speed) { clearInterval(element.timer); // 判断，有要继续执行的函数，则调用 fn &amp;&amp; fn(); } }, 30); } 3. 小结上述运动框架还有可优化完善之处，暂无更多时间进行优化，留待后继完善。当然，实际开发中可能更多地会使用到成熟的运动框架，以上的封装作为理解运动原理的一个流程，大家也可以在此基础之上继续完善。","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhanhongzj.github.io/tags/JS/"}]},{"title":"PHP 流程控制语句","slug":"php流程控制语句","date":"2016-12-13T15:29:41.000Z","updated":"2017-08-02T11:45:08.684Z","comments":true,"path":"2016/12/13/php流程控制语句/","link":"","permalink":"http://zhanhongzj.github.io/2016/12/13/php流程控制语句/","excerpt":"","text":"编程语言中的流程控制语句大都主要分为以下几类： 顺序结构 条件结构 循环结构 跳转语句 顺序结构是最基本的流程控制语句，按照书写顺序从上向下依次执行，不过多赘述。 1. 条件结构PHP 中的条件结构主要有以下几种： 简单 if 语句 if-else if-else if-else switch 和大多数其它编程语言类似，先来看看条件结构的语法。 1.1 简单 if语法： if (expr) { // statement; } 如果 expr 表达式为真，则执行 statement 语句块，否则，跳过该结构继续向后执行。 $num1 = 34; $num2 = 10; if ($num1 &gt; $num2){ echo ($num1 . &quot;&gt;&quot; . $num2 . &quot;&lt;br&gt;&quot;); } echo (&quot;执行结束...&quot;); 1.2 if-else语法： if (expr) { // statement1; } else { // statement2; } 如果条件表达式 expr 成立，则执行 if 分支语句块1，否则执行 else 语句块2。语句块1与语句块2为互斥关系，即不能都执行。 $num1 = 4; $num2 = 10; if ($num1 &gt; $num2){ echo ($num1 . &quot;&gt;&quot; . $num2 . &quot;&lt;br&gt;&quot;); } else { echo ($num . &quot;&lt;&quot; . $num2 . &quot;&lt;br&gt;&quot;); } echo (&quot;执行结束...&quot;); 1.3 if-else if-else多重 if，语法： if (expr1) { // statement1; } else if (expr2) { // statement2; } …… { // statement n; } else { // statement n+1; } 如果条件表达式1成立，则执行语句序列1，否则执行判断条件表达式2，表达式2成立，则执行语句序列2，否则向下判断表达式，以此类推，如果所有条件表达式都不满足，则执行最后的 else 语句块中的语句序列 n+1。 $num1 = 4; $num2 = 10; if ($num1 &gt; $num2){ echo ($num1 . &quot;&gt;&quot; . $num2 . &quot;&lt;br&gt;&quot;); } else if ($num1 === $num2) { echo ($num . &quot;===&quot; . $num2 . &quot;&lt;br&gt;&quot;); } else { echo ($num . &quot;&lt;&quot; . $num2 . &quot;&lt;br&gt;&quot;); } echo (&quot;执行结束...&quot;); 1.4 switch多重 if 在实现多分支选择时，如果是等值的多分支选择，条件判断如果有多个，则可能十分冗长，则可使用 switch 来实现等值条件的多分支选择。 语法： switch(variable) { case value1: // statement1; break; case value2: // statement2; break; case ……: ………… default: // statement n; } switch 根据 variable 的值依次与各 case 后的 valueN 比较，如果不等，则继续比较下一个 case，如果相等，则执行对应语句，直到 switch 结束或遇到 break; 为止。default 块为缺省块，即当 variable 与所有 valueN 都不等时，执行缺省块。 $score = 75; switch((integer)($score / 10)){ case 10: case 9: echo (&quot;A&quot;); break; case 8: echo (&quot;B&quot;); break; case 7: echo (&quot;C&quot;); break; case 6: echo (&quot;D&quot;); break; default: echo (&quot;E&quot;); } 2. 循环结构我们可以使用循环结构来解决重复使用某段代码或函数的问题。PHP 中循环结构主要有：while、do-while、for、foreach。 2.1 while语法： while (expr) { // statement; } 当 expr 条件为真时，执行循环体 statement 语句，循环体执行完毕后继续判断 expr 条件，重复上述步骤，直到 expr 条件为假退出循环。 $sum = 0; $currNum = 1; // 计算 1~100之和 while ($currNum &lt;= 100) { $sum += $currNum; $currNum++; } echo (&quot;1+2+3+...+99+100=$sum&quot;); echo (&quot;&lt;br&gt;执行结束...&quot;); 2.2 do-while语法： do { // statement; } while (expr); 先无论如何执行一次循环体的操作，再判断条件，在条件满足的情况下，继续执行循环体操作，然后判断条件，重复，直到条件为假退出循环。 $sum = 0; $currNum = 1; do { $sum += $currNum; $currNum++; } while ($currNum &lt;= 100); echo (&quot;1+2+3+...+99+100=$sum&quot;); echo (&quot;&lt;br&gt;执行结束...&quot;); 2.3 for语法： for (expr1; expr2; expr3) { // statement; } 执行流程说明： 执行变量初始化表达式 expr1，通常这个变量是用于循环条件的控制； 执行循环条件判断 expr2 循环条件满足，则执行循环体操作，循环条件不满足，则跳到第 6 步； 执行变量更新表达式 expr3，通常是循环变量更新，以构建退出循环的条件； 回到第 2 步； 退出循环结构。 // 计算 10! $factorial = 1; // 保存阶乘结果 for ($i = 10; $i &gt;= 1; $i–) { $factorial *= $i; } echo (“10! = $factorial”); 2.4 foreachforeach 常用于数组元素遍历。 语法： foreach (array_expression as $value) { // statement; } // 或 foreach (array_expression as $key=&gt;$value) { // statement; } $value 表示遍历到的元素值，$key 表示遍历到的索引。 示例1： $arr = array(38,29,64,15,88); foreach($arr as $item) { echo &quot;$item&lt;br&gt;&quot;; } 示例2： $arr = array(38,29,64,15,88); foreach ($arr as $key=&gt;$value){ echo &quot;$key = $value&lt;br&gt;&quot;; } 3. 跳转语句3.1 break在使用循环结构时，有时会遇到循环次数不定的情况，但条件表达式不好表示，这时可以固定将条件表达式置为 true，人为设置死循环。为了能够在循环体中满足一定条件的时候还是能够退出循环，可以使用 break; 语句。 while (true) { $tmp = rand(1, 20); echo $tmp . &quot; &quot;; if ($tmp === 10) { echo &quot;&lt;div&gt;变量值终于为10了&lt;/div&gt;&quot;; break; } } 使用 break; 不仅可以跳出当前循环，还可以指定跳出几层循环，格式为 break $num;，但不推荐使用。 3.2 continue如果只想终止当前一次循环，还能够继续判断条件执行下一次循环，那么可以使用 continue。 $arr = array(3,5,2,1,8,9,6); for ($i = 0; $i &lt; 7; $i++) { if ($i % 2 == 0) continue; echo &quot;输出：$arr[$i]&lt;br&gt;&quot;; } 使用 continue $num; 和 break 类似，可以跳出几层循环，但这样一来，对程序逻辑的理解跳跃性就比较大，不推荐使用。 4. 小结流程控制语句在程序中是必不可少的，也是变化丰富的。再复杂的业务逻辑，都是通过流程控制语句的拆分组合演化而来的，所以对于流程控制语句，我们一定要不断练习和总结，掌握住一套属于自己的方法和技巧。","categories":[{"name":"后台","slug":"后台","permalink":"http://zhanhongzj.github.io/categories/后台/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhanhongzj.github.io/tags/PHP/"}]},{"title":"PHP 语言基础","slug":"php-语言基础","date":"2016-12-11T12:09:29.000Z","updated":"2017-08-02T11:30:32.108Z","comments":true,"path":"2016/12/11/php-语言基础/","link":"","permalink":"http://zhanhongzj.github.io/2016/12/11/php-语言基础/","excerpt":"","text":"1. PHP 标记PHP 文件的默认扩展名为 .php，在 PHP 文件中通常包含 HTML 标签和一些 PHP 脚本代码。我们可以将 PHP 脚本放在文档的任何位置，但为了与 HTML 元素区分开，需要使用一些特殊的标记来进行区分。 1.1 标准风格将 PHP 脚本用 &lt;?php ?&gt; 的标记包含起来： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一个 PHP 页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;第一个 PHP 页面&lt;/h1&gt; &lt;?php echo &quot;hello world...&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt; 标准风格的标记是推荐使用的标记，在 HTML、XHTML、XML 中都可以使用。 echo 主要用于输出内容，向页面输出时，可包含 HTML 标签。 1.2 脚本风格使用 &lt;script language=&quot;php&quot;&gt;&lt;/script&gt; 标记： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一个 PHP 页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;第一个 PHP 页面&lt;/h1&gt; &lt;script language=&quot;php&quot;&gt; echo &quot;这是脚本风格...&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1.3 简短风格使用 &lt;? ?&gt; 标记： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一个 PHP 页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;第一个 PHP 页面&lt;/h1&gt; &lt;? echo &quot;这是简短风格...&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt; 1.4 asp 风格使用 &lt;% %&gt; 标记： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一个 PHP 页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;第一个 PHP 页面&lt;/h1&gt; &lt;% echo &quot;这是 asp 风格...&quot;; %&gt; &lt;/body&gt; &lt;/html&gt; 注意，要使用简短风格和 asp 风格，还需要到 php.ini 文件中进行配置，将 short_open_tag、asp_tags 设置为 ON，再重新服务器，但还是推荐标准风格。 2. 注释注释，即解释说明，主要用于说明代码的编写者、编写时间、逻辑、用意等，方便代码阅读者进行阅读。注释不会影响程序的正常执行，在执行过程中，注释内容会被忽略。 PHP 中可以使用的注释有三种： //：单行注释，注释范围从 // 开始，到行尾结束 / /：多行注释，以 / 开头，/ 结束，包含在开始与结束标记之间的内容为注释内容 #：shell注释，类似于单行注释 注意，多行注释不能出现嵌套使用，单行注释中也不要出现 ?&gt; 这样的标记，解释器会误以为 PHP 脚本结束了。 3. 标识符与关键字标识符通常是我们自己定义如变量名、类名、方法名时用到的标记。关键字是 PHP 语言本身特有的有特殊含义的单词标记，通过这些有特殊含义的单词组织 PHP 的程序逻辑。 自定义标识符名时，通常遵循以下规则： 可以包含字母、数字、下划线 不能以数字开头 区分字母大小写 不能使用关键字 4. 变量变量是在内存中数据存储的区域，与其它语言一样，变量也具有三大要素：变量数据类型、变量名与变量值。 4.1 变量定义PHP 中变量命名规则为： 变量以 $ 符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ） 变量名不能包含空格 变量名是区分大小写的（$y 和 $Y 是两个不同的变量） PHP 和 JavaScript 类似，也是一门弱类型的语言，即在定义变量时不需要指明变量数据类型，变量的类型在赋值时自动确定。这也是弱类型语言与强类型语言的差别。 示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一个 PHP 页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;第一个 PHP 页面&lt;/h1&gt; &lt;?php $txt=&quot;Hello world!&quot;; $x=5; $y=10.5; echo &quot;x = $x, y = $y, txt = $txt&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt; 4.2 变量作用域变量必须在有效范围内使用，如果变量超出其有效范围，也就推动了变量的意义。变量作用域如下： 作用域 描述 局部变量 在函数内部定义的变量，其作用域在所在函数内部 全局变量 定义在所有函数外的变量，其作用域是整个 PHP 文件，但在用户自定义函数内部是不可用的。如果希望在用户自定义函数内部使用到全局变量，则要使用 global 关键字声明全局变量 静态变量 能够在函数调用结束后仍保留变量值，当再次回到其作用域时，又可以继续使用原来的值。而一般变量是在函数调用结束后，其存储的数据值即被清除，所占的内存空间也被释放。使用静态变量时，先要用关键字 static 来声明变量，把关键字 static 放在要定义的变量之前 局部变量与全局变量： $test = &quot;函数外部的 test 变量...&quot;; function fn() { $test = &quot;fn 函数内部的 test 变量...&quot;; echo &quot;fn函数内部输出：$test&lt;br&gt;&quot;; global $test; $test = &quot;修改了外部的 test 变量...&quot;; echo &quot;fn函数内部输出：$test&lt;br&gt;&quot;; } fn(); echo &quot;函数外部输出：$test&lt;br&gt;&quot;; 执行结果： fn函数内部输出：fn 函数内部的 test 变量... fn函数内部输出：修改了外部的 test 变量... 函数外部输出：修改了外部的 test 变量... 局部变量与静态变量： function fn1(){ static $num = 0; $num += 1; echo &quot;fn1 : num = $num &quot;; } function fn2(){ $num = 0; $num += 1; echo &quot;fn2 : num = $num &quot;; } for($i = 0; $i &lt; 5; $i++) { fn1(); } echo &quot;&lt;br&gt;&quot;; for($i = 0; $i &lt; 5; $i++) { fn2(); } 执行结果： fn1 : num = 1 fn1 : num = 2 fn1 : num = 3 fn1 : num = 4 fn1 : num = 5 fn2 : num = 1 fn2 : num = 1 fn2 : num = 1 fn2 : num = 1 fn2 : num = 1 5. 数据类型PHP 支持 8 种数据类型，这 8 种数据类型又可分为标量类型、复合类型与特殊类型。 标量类型：boolean、integer、float、string 复合类型：array、object 特殊类型：resource、null 5.1 标量类型 类型 描述 boolean 布尔类型，取值为 true 或 false integer 整数，可以是正数或负数 float 浮点型，用于存储数字，它有小数位 string 字符串，存储连续的字符序列 boolean boolean 布尔型通常用于表示真假，它有两个取值：true、false，是 PHP 中常用的类型之一。boolean 类型通常用在条件结构或循环结构的条件表达式中。 在某些情况下，其它类型也可以自动向 boolean 类型转换，通常这些会转为 boolean 型的 false：0、0.0、”0”、””(空字符串)、未赋值的数组…… integer integer 为整型类型，只能表示整数，可以是十进制、八进制、十六进制。八进制以 0 开头，十六进制以 0x 开头。32 位操作系统中，integer 表示数字在 -2^31 至 2^31 - 1 范围内。在为变量赋值时，如果赋值数字超过整数的范围（称为溢出），将会被当作 float 浮点型数据处理。 float float 为浮点数类型，既可用于存放整数，又可用于存放小数。在 32 位操作系统中，float 表示数字在 1.7E-308 至 1.7E+308 范围内。 浮点数写法可以有两种，平时常用的是如 3.14 之类的写法，也可使用如 7.96E+5 的写法（科学计数法）。PHP 4.0 之前，浮点型为 double（双精度浮点数），两者之间没有区别。 string 在 PHP 中，有三种表示字符串的方式，分别是使用单引号（’）、双引号（”）或界定符（&lt;&lt;&lt;）来表示。 单引号（’）与双引号（”）的区别在于，单引号中如果包含变量会按普通字符串输出，而双引号中如果包含变量会自动替换成变量实际值输出。 界定符是从 PHP 4.0 开始支持的，使用时在界定符后跟一个标识符，然后是字符串内容，字符串内容结束后要以同样的标识符标记，如： echo &lt;&lt;&lt;str 这是一个字符串内容 str; &lt;&lt;&lt; 后跟的 str 就是标识符，结束标识符必须另起一行，并且不允许有空格，也不允许在其前后有任何空格或其它符号。 5.2 复合类型 类型 描述 array 一组类型相同的值的集合 object 类的实例，通常使用 new 创建 array 数组是一组数据的集合。通过数组，可以将一系列数据组织起来，形成一个可操作的整体。 数组中的每个数据称为一个元素，元素通常包括索引和值两个部分，索引可为数字或字符串，值可以取多种数据类型。 定义数组的语法为： $arr = (value1, value2, value3, ...); // 或 $arr[key] = value; // 或 $arr = array(key1=&gt;value1, key2=&gt;value2, ...); key 为数组元素的索引，value 是数组元素值。声明数组后，数组中元素个数也可以动态改变，数组长度也会自动更新。 object 对象类型稍后介绍。 5.3 特殊类型 类型 描述 resource 资源也称句柄，保存的是到外部资源的一个引用，是通过专门的函数来建立和使用的 null 一个特殊的值，表示变量没有值，唯一值为null，通常用于表示对象的空 5.4 数据类型转换PHP 的数据类型转换是在待转换的变量前加上小括号的方式来转换，如： $num = 5; $b = (boolean)$num; echo $num; 注意，转换为 boolean 类型时，null、0、未赋值的变量或数组被转换为 false，其它的转换为 true；转换成整型时，布尔型的 false 转换为 0，true 转换为 1，浮点型的小数部分被丢弃，字符串型如果以数字开头就截取到非数字位，否则输出 0。 也可以使用 settype() 函数来转换： boolean settype(mixed var, string type) var 为待转换的变量，type 为转换的数据类型，如果转换成功，settype() 返回 true，否则返回 false。 如： $str = &quot;8899.283&quot;; $b = settype($str, &quot;integer&quot;); $num = $str*2; echo $num; 使用类似 (boolean)、(integer) 的方式转换，原变量的值不会发生改变，但使用 settype() 函数转换后，原变量会被改变为转换后的值。 5.5 类型检测PHP 内置了用于检测数据类型的函数： 函数 描述 is_boolean 检测是否为 boolean 类型 is_string 检测是否为 string 类型 is_float/is_double 检测是否为 float 类型 is_integer/is_int 检测是否为 integer 类型 is_null 检测是否为 null is_array 检测是否为 array 类型 is_object 检测是否为 object 类型 is_numeric 检测是否为数字或由数字组成的字符串 6. 常量常量是一个简单值的标识符，常量值被定义后，在脚本的其他任何地方都不能被改变。一个常量名由英文字母、下划线、和数字组成，但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。 设置常量需要使用到 define() 函数： bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) 参数 name 为必选参数，表示常量名称，即标识符。value 也为必选参数，表示常量的值。case_insensitive 是可选参数，如果设置为 true，该常量则大小写不敏感，该参数默认是大小写敏感的。 // 区分大小写的常量名 define(&quot;GREETING&quot;, &quot;欢迎访问小明的家&quot;); echo GREETING; // 输出 &quot;欢迎访问小明的家&quot; echo &apos;&lt;br&gt;&apos;; echo greeting; // 输出 &quot;greeting&quot; // 不区分大小写的常量名 define(&quot;WELCOME&quot;, &quot;欢迎访问小明的家&quot;, true); echo welcome; // 输出 &quot;欢迎访问小明的家&quot; 常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。以下实例演示了在函数内使用常量，即便常量定义在函数外也可以正常使用常量： define(&quot;GREETING&quot;, &quot;欢迎访问小明的家&quot;); function myTest() { echo GREETING; } myTest(); // 输出 &quot;欢迎访问小明的家&quot; 7. 运算符PHP 中的运算符和其它语言也是类似的。 算术运算符 主要用于处理算术运算，在数字的处理中应用最多。有 +(加)、-(减)、*(乘)、/(除)、%(模)、++(自增)、–(自减) 运算。 字符串运算符 字符串运算符只有一个，即英文半角状态下的小圆点（.），它的作用是将两个字符串连接起来，形成一个新的字符串，其它语言中多用 “+” 作字符串连接，但在 PHP 中 “+” 只用于算术运算。 赋值运算符 =，用于将运算符右边的表达式值赋值给左边的变量保存。 复合运算符 +=、-=、*=、/=、%=、.=，作用是将运算符左边的变量与右边的表达式作第一个运算符号的运算操作，将运算结果保存回左边的变量中。 比较运算符 主要用于大小比较，有：&gt;、&lt;、&gt;=、&lt;=、==、===、!=、!==。== 与 === 号是相等比较，前者是比较值相同即可，如果类型不一致，尝试类型转换后再比较，而后者是恒等比较，即类型不一致，直接不相等。 逻辑运算符 &amp;&amp; 或 and，表示逻辑与，两个表达式都为真时结果为真。 || 或 or，表示逻辑或，两个表达式只要有一个为真，结果为真。 xor，表示逻辑异或，两个表达式一真一假时，结果为真。 !，表示逻辑非，取逻辑相反值。 三目运算符 ?:，作用是根据一个表达式在另两个表达式中选择一个。? 问题前为条件的表达式，? 问题与 : 冒号之间是条件为真时返回的表达式，而 : 冒号后是条件为假时返回的表达式。 位运算符 位运算符主要用于对二进制数按位进行运算，&amp; 表示按位与，| 表示按位或，^ 表示按位异或，~ 表示按位取反，&lt;&lt; 表示向左移位，&gt;&gt; 表示向右移位。实际开发中，除非涉及算法优化，否则还是很少用到位运算符。 错误控制运算符 错误控制运算符可以对程序中出现错误的表达式进行操作，进而对错误信息进行屏蔽，使用方法是在可能出现错误的表达式前添加 @ 符号。@ 仅仅是对错误信息进行屏蔽，不会真正解决错误问题，不推荐使用。 这些运算符如果结合到一起使用，同样存在优先级的问题，但是这么多运算符，我们要去一一的记优先级的话，也显得很繁琐，所以实际应用的时候，如果不清楚优先级的情况，可适当使用括号来区分。 8. 函数实际开发中，会经常遇到重复的操作，如数据添加、修改、查询、字符串操作等，如果每个操作都重复去编写代码，不仅写起来很头痛，如果后期代码要维护、修改，那就会更头痛了。我们可以使用函数来解决这个问题，函数就是可以被重复使用的代码块。 8.1 函数定义与调用创建函数的语法结构为： function fn_name($var1, $var2, ...) { // main_body; } function 是声明函数的关键字，fn_name 为函数名，$var1, $var2, … 为函数形式参数列表，main_body 为函数主体，实现功能的代码块就写在主体中。 函数定义之后，不会主动起作用，需要经过调用才能发挥作用。函数调用与其它语言类似，通过函数名引用，并传递正确的实际参数即可。 function area($width, $height) { echo &quot;矩形宽为：$width ，高为：$height ，面积为：&quot; . $width * $height; } area(3, 5); 结果： 矩形宽为：5 ，高为：8 ，面积为：40 8.2 函数参数在函数体内部进行运算时，所需要的数据如果函数内不能解决数据来源问题，或不能通过全局变量解决时，所需要的额外数据就可以通过参数传递。函数定义时给定的参数列表称为形式参数列表，简称形参；函数调用时给定的参数列表称为实际参数列表，简称实参。 在 PHP 中，参数的传递的方式有：按值传递，按引用传递，默认参数。 1. 按值传递 将实参的值赋值到对应的形参变量中，在函数内部的操作仅针对形参变量进行，操作结果不会影响到实参，这种参数传递是按值传递。如： function area($width, $height) { echo &quot;矩形宽为：$width ，高为：$height ，面积为：&quot; . $width * $height; // 运算后修改形参值 $width += 5; $height += 3; } $w = 5; $h = 8; area($w, $h); echo &quot;&lt;br&gt;函数调用结束后：\\$w = $w ，\\$h = $h&quot;; 执行结果： 矩形宽为：5 ，高为：8 ，面积为：40 函数调用结束后：$w = 5 ，$h = 8 2. 按引用传递 按引用传递就是将实参的内存地址传递给形参，这样，在函数体内部所有对形参的操作都会影响到实参的值。引用传递是在函数定义时就在形参前添加 “&amp;” 符号，调用时直接传递实参变量即可。 function area(&amp;$width, &amp;$height) { echo &quot;矩形宽为：$width ，高为：$height ，面积为：&quot; . $width * $height ; // 运算后修改形参值 $width += 5; $height += 3; } $w = 5; $h = 8; area($w, $h); echo &quot;&lt;br&gt;函数调用结束后：\\$w = $w ，\\$h = $h&quot;; 执行结果： 矩形宽为：5 ，高为：8 ，面积为：40 函数调用结束后：$w = 10 ，$h = 11 3. 默认参数 默认参数也叫可选参数，即在函数调用时，参数可以不传递，在函数体内部对未传递的参数取一个默认值。在函数声明时可以指定某个参数为可选参数，将可选参数放在参数列表末尾，并为其指定默认值。 function area($radius, $pi=3.14) { echo &quot;半径为 $radius 的圆面积为：&quot; . $pi * $radius * $radius . &quot;&lt;br&gt;&quot;; } area(2); area(2, 3.14159); 执行结果： 半径为 2 的圆面积为：12.56 半径为 2 的圆面积为：12.56636 8.3 返回值如果需要在函数外部使用到函数体中数据处理的结果，则需要使用返回值。PHP 使用 return 语句来将返回值传递给调用者。 return 的作用是将函数的值返回给函数的调用者，即将程序控制权返回到调用者的作用域，所以函数体内执行了 return 语句，则结束了函数的调用。如果在全局作用域内使用了 return 语句，那么将终止脚本的执行。 function calc($salary, $tax=0.03, $minus=0){ return $salary - (($salary - 3500) * $tax - $minus); } $income = calc(5000); echo &quot;月工资 5000，到手：$income&quot;; 执行结果： 月工资 5000，到手：4955 9. 小结以上主要简单介绍了 PHP 语言的基础知识，当然对于初学者来说，这些内容并不十分详实，适合有一定编程基础的读者阅读。待时间允许再做详细整理…","categories":[{"name":"后台","slug":"后台","permalink":"http://zhanhongzj.github.io/categories/后台/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhanhongzj.github.io/tags/PHP/"}]},{"title":"PHP 集成环境搭建","slug":"php-environment","date":"2016-12-10T15:33:49.000Z","updated":"2017-08-02T11:12:46.299Z","comments":true,"path":"2016/12/10/php-environment/","link":"","permalink":"http://zhanhongzj.github.io/2016/12/10/php-environment/","excerpt":"","text":"俗话说，工欲善其事，必先利其器。要学习 PHP 开发，也必须先搭建能够运行 PHP 的环境。 作为入门介绍，不推荐完全自己配置并搭建环境，因为自己搭建环境就得独立安装 apache、php、mysql及各种管理工具，然后再进行相关配置，这无疑增加了入门难度。 推荐使用 PHP 集成环境来学习 PHP 开发，下面以 wampserver 集成开发环境为例在 32 位 windows 操作系统中介绍 PHP 环境安装。 下载wampserver 官方网站为 http://www.wampserver.com/en/，点击导航中 DOWNLOAD 下载，根据操作系统位数选取 32 位或 64 位版本下载。 下载完毕后不能立刻安装，因为要安装 wmap 还需要 VC++ 运行库的支持。详情可见 https://sourceforge.net/projects/wampserver/files/WampServer%203/WampServer%203.0.0/ 的说明。 根据操作系统位数下载 VC++ 运行库。Wampserver 2.4, 2.5 和 3.0 版本需要 VC9, VC10, VC11 的运行库， 如果 PHP 版本为 7 以上，apache 版本为 2.4.17 以上，还必需 VC13, VC14 运行库。 VC9 Microsoft Visual C++ 2008 SP1 Redistributable Package (x86) (32bits) Microsoft Visual C++ 2008 SP1 Redistributable Package (x64) (64bits) VC10 Microsoft Visual C++ 2010 SP1 Redistributable Package (x86) Microsoft Visual C++ 2010 SP1 Redistributable Package (x64) VC11 Visual C++ Redistributable for Visual Studio 2012 Update 4 (x86 and x64) VC13 Visual C++ Redistributable Packages for Visual Studio 2013 VC14 Visual C++ Redistributable Packages for Visual Studio 2015 Update 3 特别需要注意的是，如果你的操作系统是 64 位 windows 系统，你既要安装 32 位的 VC++ 运行库，又需要安装 64 位的 VC++ 运行库，即使安装的不是 64 位的 wampserver。 安装先安装 VC++ 运行库，按照从小到大顺序一一安装；再安装 wampserver。按下图中各程序顺序安装即可： 注意，最好将 wampserver 安装在某个根目录下的文件夹中，比如：c:\\wamp、d:\\wamp 目录。确保在安装路径中不要有空格或特殊符号，不要安装在如 c:\\program files\\ 或 c:\\program files (x86)\\ 下，当然更不能安装在中文路径下了。 安装完成后，运行桌面 Wampserver 快捷方式，在任务栏右下角，会出现 wampserver 管理工具图标： 可以右键单击该图标，进入 Language 菜单项，选择 Chinese 将语言设置为简体中文。 测试启动 Wampserver 后，如果各端口未被占用，则可以直接打开浏览器，在地址栏中输入 http://localhost 或 http://127.0.0.1 进行访问，能够打开类似如下页面，则说明 Wampserver 安装成功了： 当然，Wampserver 默认的 apache 服务器端口为 80 端口，mysql 数据库端口为 3306 端口，如果想使用其它的端口，可以直接通过配置工具修改：","categories":[{"name":"后台","slug":"后台","permalink":"http://zhanhongzj.github.io/categories/后台/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://zhanhongzj.github.io/tags/PHP/"}]},{"title":"JavaScript 闭包","slug":"闭包","date":"2016-01-14T12:34:02.000Z","updated":"2017-08-02T10:07:15.553Z","comments":true,"path":"2016/01/14/闭包/","link":"","permalink":"http://zhanhongzj.github.io/2016/01/14/闭包/","excerpt":"","text":"1. 概述闭包（closures），在 MDN 解释为： Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. 闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。 闭包是 JavaScript 语言的一个特色，当然也是它的一大难点，很多高级应用都要依靠闭包实现，或者我们平常编码过程中，也在有意无意间使用到闭包。 2. 作用域链在理解闭包，首先就要理解 JavaScript 中的作用域链。 在 JavaScript 中有两种作用域：全局作用域和函数作用域（在 ES6 中引入了块级作用域）。 在函数中定义的变量只能在本函数体中使用到，在函数外部不能直接调用函数体内部定义的变量，但函数中可以调用到全局作用域中定义的变量。 如果函数中有内嵌函数的定义，则在内嵌函数中可以访问到外部函数中定义的变量，也可访问到全局作用域中的变量，但在外部函数中不能访问内嵌函数中定义的变量。这样，就形成了作用域链，即内嵌函数可调用父级或祖先级函数中定义的变量，但父级函数不能调用子级或后代函数中定义的变量。 function outer(){ var outVar = 10; function inner(){ var inVar = 20; console.log(&quot;inner 中调用外部函数变量 outVar = &quot; + outVar); } inner(); console.log(&quot;outer 中调用内嵌函数变量 inVar = &quot; + inVar); } outer(); 执行结果： inner 中调用外部函数变量 outVar = 10 ReferenceError: Can&apos;t find variable: inVar 在 JavaScript 中，变量的作用域是由它在源代码中所处位置决定的，并且嵌套的函数可以访问到其外层作用域中声明的变量。 3. 闭包如果有这样一种需求，我们需要在外部使用到函数内的变量，但正常情况下，通过直接调用的方式是不能访问到的，这就需要变通的方法了。 function outer() { var i = 1; var inner = function(){ return ++i; } return inner; } var result = outer(); console.log(&quot;第一次调用：&quot; + result()); console.log(&quot;第二次调用：&quot; + result()); console.log(&quot;第三次调用：&quot; + result()); 执行结果： 第一次调用：2 第二次调用：3 第三次调用：4 上例中，我们要使用到 outer 函数内部的变量 i，每次打印是在原有数值基础上自增 1。因在函数外部不能直接通过变量名对其进行访问，而嵌套在内部的 inner 函数则能够访问到外部函数变量 i，所以返回了内部函数的引用 inner，这样，当 outer 函数调用结束后，放置在 result 中的实际为内嵌函数的引用，这样就可以继续使用到在 outer 函数内部定义的变量 i 了。这就是闭包。 以前常用到的定时器，相信大家写过类似的代码片段： function fn(){ var i = 0; var timer = setInterval(function(){ console.log(i++); if(i &gt; 10) clearInterval(timer); }, 50); } fn(); fn 函数调用结束后，按理说在 fn 函数内部的局部变量 i、timer 作用域该结束了，但 setInterval()函数的异步执行过程中，仍然可以使用到这两个变量的值。这也是典型的闭包使用情况。 4. 一个故事来解释闭包可以有哪些适用场景前，我喜欢下面这个例子解释。 很久很久以前： 有一位公主…… function princess() { 她住在一个充满冒险的奇妙世界里，遇到了她的白马王子。白马王子带着她骑着独角兽开始周游世界，与巨龙战斗，巧遇会说话的动物，还有很多其他的不可思议的新奇事物。 var adventures = []; function princeCharming() { /* ... */ } var unicorn = { /* ... */ }, dragons = [ /* ... */ ], squirrel = &quot;Hello!&quot;; 但她不得不回到自己乏味的王国里，例行去见那些成年人。 return { 她会经常给大人分享她最近作为公主时的充满奇幻的冒险经历。 sayStory: function() { return adventures[adventures.length - 1]; } }; } 但在大人的眼里，公主仅仅只是一个小女孩儿…… var littleGirl = princess(); ……在讲着一些神奇的、充满幻想的故事。 littleGirl.sayStory(); 即便所有大人都知道他们眼前的小女孩是真的公主，但是他们绝不相信有巨龙或独角兽，因为他们自己从来没有见到过。大人们说它们只存在于小女孩的想象之中。 但是我们却知道小女孩述说的是事实…… 5. 闭包适用场景通常闭包有如下两种适用场景： 在内存中维持变量，如缓存数据 保护函数体内变量的安全，如为对象设置私有属性 5.1 缓存数据一个比较常用到的例子就是，利用循环为元素绑定事件。 让每个 div 元素被点击时，都能正确弹出当前被点击的 div 的索引： &lt;div&gt; div-1 &lt;/div&gt; &lt;div&gt; div-2 &lt;/div&gt; &lt;div&gt; div-3 &lt;/div&gt; &lt;div&gt; div-4 &lt;/div&gt; &lt;div&gt; div-5 &lt;/div&gt; 如果使用如下写法： &lt;script&gt; function handle(){ var divs = document.getElementsByTagName(&quot;div&quot;); for (var i = 0, len = divs.length; i &lt; len; i++){ divs[i].onclick = function(){ alert(&quot;你点击的 div 索引为：&quot; + i); } } } handle(); &lt;/script&gt; 这时，在每个 div 上点击时弹出的结果都是你点击的 div 索引为：5。这是因为事件处理是异步的，但事件绑定是同步的，会先执行完循环体的 5 次操作，为每个 div 绑定上 onclick 事件。 这个过程中，变量 i 的值一直在递增变化，当所有 div 元素都被遍历后，i 的值自增到 5 退出循环结构。函数 handle 调用结束后，由于在事件响应程序中仍然存在变量 i 的引用，如果释放变量 i 的资源，会导致事件响应程序执行错误，所以为了保证事件响应程序中仍然能正确使用到变量 i，会将变量 i 的值一直保留在内存中，但保留的 i 的值为 5。 如果要正确输出索引值，可使用闭包修改如下： &lt;script&gt; function handle(){ var divs = document.getElementsByTagName(&quot;div&quot;); for (var i = 0, len = divs.length; i &lt; len; i++){ divs[i].onclick = clk(i); } } function clk(index){ return function(){ alert(&quot;你点击的 div 索引为：&quot; + index); } } handle(); &lt;/script&gt; 在为每个 div 绑定事件时，调用 clk() 函数将与 div 关联的变量值 i 传递到 clk() 函数内部使用，因为内部返回了一个内嵌函数的引用，该内嵌函数功能的实现依赖于外部函数中的局部变量 index，所以 index 变量的值会在内存中得以缓存。 由于每个 div 绑定事件时，都调用了 clk() 函数来实现事件绑定操作，所以与之对应的变量索引 i 的数值也都在内存中得以缓存，只是这个值不是以 i 的名称来缓存。当我们再次测试时，就可以正确打印出所点击 div 的索引了。 当然以上功能的实现也可以通过自定义属性方式实现： &lt;script&gt; function handle(){ var divs = document.getElementsByTagName(&quot;div&quot;); for (var i = 0, len = divs.length; i &lt; len; i++){ divs[i].index = i; divs[i].onclick = function(){ alert(&quot;你点击的 div 索引为：&quot; + this.index); }; } } handle(); &lt;/script&gt; 或是通过 let 命令来实现： &lt;script&gt; function handle(){ var divs = document.getElementsByTagName(&quot;div&quot;); for (let i = 0, len = divs.length; i &lt; len; i++){ divs[i].onclick = function(){ alert(&quot;你点击的 div 索引为：&quot; + i); }; } } handle(); &lt;/script&gt; 5.2 为对象设置私有属性如果有一个对象，拥有年龄这样一个属性，我们要限定年龄的取值范围在 18~25 岁之间，以类似 Java 面向对象的方式来实现，可模拟如下： &lt;script&gt; function Student(){ var age = 18; this.getAge = function(){ return age; } this.setAge = function(value) { if (value &lt; 18 || value &gt; 25) throw new RangeError(&quot;age must between 18 and 25&quot;); age = value; } } var stu = new Student(); console.log(stu.getAge()); // 18 stu.setAge(36); // 报错：RangeError &lt;/script&gt; age 表示学生的年龄，这样的一个变量如果对于任何人都可以修改值，那么如果给定一个负值，比如 -35，虽然就语法上来说没问题，但就实际逻辑来说，一个人不可能年龄为 -35 岁，所以为了保障这种数据的安全，可以使用闭包来解决。 对 Student 函数内部的局部变量 age 来说，本应该在 Student() 函数通过 new 调用结束后就释放掉资源，但在对象的 getAge/setAge 方法中仍然有对其的引用，释放资源会导致 getAge/setAge 功能不能正常完成，所以其值会保存在内存中。但要修改 age 年龄值时，由于它的作用域问题，我们没法在 Student 函数外直接通过调用 age 的方式来修改，仅能使用提供的 setAge 方法接口修改 age 值，这就保证了对 age 修改赋值的安全性。 6. 一点误解以前在查阅资料时，经常见到说不要轻易使用闭包，否则容易造成内存泄漏的说法。 直到看到这篇文章：《js闭包测试》 闭包里面的变量是我们需要使用到的变量（lives），而内存泄漏通常是指访问不到的变量依然占据内存空间，不能够对其占据的空间再次利用。显然闭包是不属于访问不到的内存空间。 之所以有这样的说法，大概是因为 IE，特别是 IE6 的 bug 吧。当然这是 IE 浏览器的问题，不是闭包的问题。 现代浏览器在 JavaScript 引擎中大都优化处理了闭包情形下的垃圾回收，所以关于内存泄漏的说法，我们大可不必再理会了。","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://zhanhongzj.github.io/tags/JS/"}]},{"title":"浏览器是怎样工作的？","slug":"浏览器是怎样工作的","date":"2016-01-02T22:24:46.000Z","updated":"2017-08-02T09:34:50.210Z","comments":true,"path":"2016/01/03/浏览器是怎样工作的/","link":"","permalink":"http://zhanhongzj.github.io/2016/01/03/浏览器是怎样工作的/","excerpt":"","text":"0. 为什么要了解浏览器是如何工作的想要写出一个最佳实践的页面，要实现性能优化，就要好好了解了解浏览器的工作原理。 了解浏览器如何进行加载，可以在引用外部样式表文件、外部 JavaScript 文件时，将他们放到合适的位置，使浏览器以最快的速度及合理的顺序将文件加载完毕。 了解浏览器如何进行解析，可以在构建 DOM 结构，组织 CSS 选择器时，选择最优的写法，提高浏览器的解析效率。 了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写 JavaScript 文件时，可以减少 “reflow” “repaint” 的消耗。 1. 浏览器的主要功能及构成浏览器的主要功能 是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。 浏览器的主要构成 浏览器的主要组件包括： 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。 浏览器引擎 － 用来查询及操作渲染引擎的接口。 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来。 网络 － 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作。 UI 后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。 JS 解释器 － 用来解释执行 JS 代码。 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 web database 技术，这是一种轻量级完整的客户端存储技术。 2. 浏览器的渲染2.1 渲染引擎简介渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。 默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式，这里先不讨论插件及扩展，只讨论渲染引擎最主要的用途——显示应用了 CSS 之后的 html 及图片。 2.2 渲染流程 渲染引擎首先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成，即以 8K 每块下载 html 页面。 然后解析页面生成 DOM 树，遇到 CSS 标签或 JS 脚本标签就新起线程去下载他们，并继续构建 DOM。 CSS 下载完后解析为 CSS 规则树，浏览器结合 CSS 规则树和 DOM 树生成 Render Tree。Render Tree 由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。 JavaScript 下载后可以通过 DOM API 修改 DOM，通过 CSSOM(CSS Object Model) API 修改样式作用域 Render Tree。注意：构建 CSSOM 会阻塞 JavaScript 的执行，JavaScript 的执行也会阻塞 DOM 的构建。 每次修改会造成 Render Tree 的重新布局和重绘。只要修改 DOM 或修改了元素的形状或大小，就会触发 Reflow，单纯修改元素的颜色只需 Repaint 一下（调用操作系统 Native GUI 的 API 绘制）。 Render Tree 构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历 Render Tree，并使用 UI 后端层绘制每个节点。也可用下图描述： 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 Render Tree。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 2.3 reflow 与 repaint现在再表述一下 HTML 页面加载和解析的流程： 用户输入网址（假设是个 html 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 html 文件； 浏览器开始载入 html 代码，发现 \\ 标签内有一个 \\ 标签引用外部 CSS 文件； 浏览器发出 CSS 文件的请求，服务器返回这个 CSS 文件； 浏览器继续载入 html 中 \\ 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； 浏览器在代码中发现一个 \\ 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 浏览器发现了一个包含一行 JavaScript 代码的 \\ 标签，赶快运行它； JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 \\ （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码； 终于等到了 \\ 的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 \\ 标签的 CSS 路径； 浏览器召集了在座的各位 \\\\\\\\ 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的 CSS 文件，重新渲染页面。 页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，我们称这个回退的过程叫 reflow。 reflow 几乎是无法避免的。现在常见的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击等，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 与 reflow 有个看上去差不多的术语叫 repaint (重绘)，如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的 repaint，重画某一部分。 2.4 引起 repaint 和 reflow 的一些操作DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的: 当你增加、删除、修改 DOM 结点时； 当你移动 DOM 的位置，或是搞个动画的时候； 当你修改 CSS 样式的时候； 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候； 当你修改网页的默认字体时； 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 2.5 reflow 优化reflow 是不可避免的，只能将 reflow 对性能的影响减到最小,给出下面几条建议： 1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className： // 不好的写法 var left = 10, top = 10; elem.style.left = left + &quot;px&quot;; elem.style.top = top + &quot;px&quot;; // 推荐写法 elem.className += &quot; classname&quot;; 2. 把 DOM 离线后修改。如： 使用 DocumentFragment 对象在内存里操作 DOM。 先把 DOM 给 display:none (有一次 reflow)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。 clone 一个 DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。 3. 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 4. 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较低的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。 5. 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是会大大减小 reflow 。 6. 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 reflow 要比 repaint 更花费时间，因为 reflow 也会引发 repaint，也就更影响性能。所以在写代码的时候，要尽量避免过多的 reflow。 以上这些仅是对浏览器工作原理的一个简单说明，大家如果对它感兴趣，可以继续搜索相关文章深入学习，因为我觉得理解浏览器的原理是很重要的，可以帮助我们写出性能更好的页面。 参考： http://taligarsiel.com/Projects/howbrowserswork1.htm https://segmentfault.com/a/1190000002629708","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"百科","slug":"百科","permalink":"http://zhanhongzj.github.io/tags/百科/"}]},{"title":"git用法","slug":"git的用法","date":"2016-01-02T03:29:44.000Z","updated":"2017-08-02T12:43:27.761Z","comments":true,"path":"2016/01/02/git的用法/","link":"","permalink":"http://zhanhongzj.github.io/2016/01/02/git的用法/","excerpt":"","text":"一、什么是 GitGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 是一个开源的分布式版本控制系统，用于敏捷高效的处理任何项目的版本问题。与常用的版本控制工具 CVS、SVN 等不同，Git 采用了分布式版本库的方式，不必服务器端软件支持。可以说 Git 是目前世界上最先进的分布式版本控制系统。 二、关于项目版本管理项目在开发的过程中，经常会出现多人分工协作进行项目开发并整合的过程，所以经常会出现一些协作开发时同步的问题，同时存在项目整体进度的控制和管理的问题，所以在程序开发行业衍生出来了版本管理工具。 版本管理工具，首先是一个内容管理工具，可以将项目的内容信息存放在版本管理服务器上方便项目组人员进行访问和查询修改。 版本管理具有里程碑意义的主要有三个阶段：CVS 阶段 –&gt; SVN 阶段 –&gt; Git 阶段。 1. CVS 阶段 项目搭建开发过程中，每次提交项目都会将整个项目提交到服务器进行保存，服务器存储着项目的 N 个备份，开发过程中的协作效率较低，同时也出现了各种传输的问题，所以慢慢淡出了行业。 2. SVN 阶段 考虑到 CVS 的缺陷，开发人员根据项目的实际情况，研发出专门针对项目版本控制的软件 Subversion（简称SVN），SVN 同样也需要搭建服务器，让项目组成员将数据存储在服务器上，但是每次改动并提交的时候，SVN 服务器并不重新保存整个项目的完整信息，而是和原来的项目进行对比，只保存改动的信息。这样就在很大的程度上对于项目版本服务器、项目协作效率有了显著的提升。所以至今为止，有很多公司依然选用 SVN 作为公司内部项目协作的版本控制软件。 3. Git 阶段 CVS 和 SVN 都是基于一个服务器的，如果脱离服务器，项目的版本保存就没有了任何意义，Git 恰恰处理了这样的问题。 4. Git 与 SVN 区别4.1 Git 是分布式的，而 SVN 不是SVN 是集中式版本控制系统，版本库是集中放在中央服务器的。通常我们干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后开始干活，活干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，加上网速慢的话，就纳闷了。 Git 是分布式版本控制系统，这是和其它非分布式的版本控制系统（SVN，CVS）最核心的区别。如果你能理解这个概念，那么你就已经上手一半了。 Git 跟 SVN 一样有自己的集中式版本库或服务器。但 Git 更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库的服务器上 chect out 代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，比如在飞机上，地下室，电梯里，通信欠发达的地区等，你仍然能够提交文件，查看历史版本记录，创建项目分支等。因为每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，版本都是在自己的电脑上。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。 4.2 Git 按照元数据的方式存储内容，SVN 是按照文件的形式存储所有的资源控制系统都是把文件的元信息隐藏在一个类似 .cvs、.svn、.git 的目录里。如果你把 .git 目录的体积大小跟 .svn 比较，你会发现它们差距很大。因为 .git 目录是你机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。 4.3 Git 和 SVN 中的分支不同分支在 SVN 中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行命令来确认代码是否被合并。所以，经常会发生有些分支被遗漏的情况。 然而，处理 Git 的分支却是相当的简单和有趣，你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。 4.4 Git 没有全局版本号，SVN 有目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。SVN的版本号实际是任何一个相应时间的源代码快照，它是从 CVS 进化到 SVN 的最大的一个突破。Git 可以使用 SHA-1 来唯一的标识一个代码快照，但这个并不能完全的代替 SVN 里容易阅读的数字版本号。 4.5 Git 内容的完整性优于 SVNGit 的内容存储使用的是 SHA-1 哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 三、Git 安装与配置1. 安装 以 windows 操作系统为例，以下操作均在 windows 7 32 bit 系统环境下进行。 在使用 Git 之前，我们需要安装 Git，下载地址：http://git-scm.com/downloads 选择 windows 操作平台（如果是其它系统对应选择即可）下载对应的安装包。 双击安装包开始安装，一路点击 “Next” 下一步即可，我在选择组件时将快捷方式添加到了桌面，以方便使用，当然不做任何修改全部使用默认推荐到最后安装完成也可。 安装完成后，在桌面可见到 Git Bash 的快捷方式，或是在开始菜单中可以找到 Git 文件夹： 或 2. 配置一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Users\\$USER。 用户信息第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录： 12$ git config --global user.name \"username\"$ git config --global user.email xxx@xxx.xx 若使用 git config 时用 –global 选项，读写的就是用户主目录下的 .gitconfig 文件。 查看配置信息1$ git config --list 四、Git 工作区、暂存区、版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage，或 index。一般存放在 “.git” 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 上图左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 从图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 五、Git 工作流程 一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 六、Git 基本操作1. 创建仓库版本库又叫仓库，英文名：repository，你可以简单的理解为一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件“还原”。 有两种取得 Git 仓库的方法，第一种是在现在的目录下，通过导入所有文件来创建新的 Git 仓库，第二种是从已有的 Git 仓库中克隆出一个新的镜像仓库来。 下面我们先使用第一种方式创建 Git 仓库（第二种创建仓库的方式稍后讲解）。 1.1 初始化仓库我先在 F: 盘下创建了一个目录（git_test，相当于我们的工作区），从 Git Bash 中进入该目录，执行如下命令： 123456789101112131415161718$ git init``` 初始化后，在当前目录下会出现一个名为 .git 的隐藏目录，这个目录是 Git 来跟踪管理版本的，所有 Git 需要的数据和资源都存放在这个目录中，所以没事千万不要手动乱改这个目录里面的文件，否则可能会把 Git 仓库给破坏了。![](/images/posts/git/git_init.png)生成的隐藏目录：![](/images/posts/git/git_init_folder.png)#### 1.2 将文件添加到仓库中 ####在 git_test 目录下新建一个文本文件 readme.txt，内容为：version 1.0.1.10161117_beta。**跟踪文件**使用如下命令跟踪文件： $ git add 文件/目录路径1234567891011121314在 `git add` 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。其实 `git add` 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。![](/images/posts/git/add_readme.png)如果和上面一样，没有任何提示，说明已经添加成功了。我们可以使用 `cat` 命令查看文件内容：![](/images/posts/git/cat_readme.png)**提交到版本库**我们先使用 `git status` 来查看状态信息： $ git status12再使用命令 `git commit` 告诉 Git，把文件提交到仓库： $ git commit -m ‘info’123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142![](/images/posts/git/git_commit.png)从上图中 `git status` 可以看出，readme.txt 文件已被跟踪，并处于暂存状态。只要在 “Changes to be committed:” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。### 2. 修改文件 ###**暂存已修改文件**现在我们修改下之前已跟踪过的文件 readme.txt，在头部插入一行：version 1.0.2，然后再次运行 `git status` 命令，会看到这样的状态报告：![](/images/posts/git/modify_not_add.png)这说明已跟踪文件的内容发生了变化（readme.txt 文件已被修改），但还没有放到暂存区。要暂存这次更新，需要运行 `git add` 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。使用 `git add` 将 readme.txt 添加到暂存区，状态：![](/images/posts/git/modify_add.png)现在 readme.txt 已暂存，下一次 commit 提交时就会记录到仓库。假设此时，我们修改 readme.txt，继续在头部插入一行：version 1.0.3，保存后，又会是什么情况呢？![](/images/posts/git/modify_add_2.png)从上图中我们可以看到，readme.txt 文件出现了两次，一次是已暂存，一次是未暂存，这是怎么回事呢？实际上 Git 只不过暂存了你运行 `git add` 命令时的版本，如果现在提交，那么提交的是添加 \"version 1.0.3\" 前的版本，而非当前工作目录中的版本。所以，运行了 `git add` 之后又作了修改的文件，需要重新运行 `git add` 把最新版本重新暂存起来：![](/images/posts/git/modify_add.png)**查看已暂存和未暂存的更新**实际上 `git status` 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 `git diff` 命令。现在，我们来解决两个问题：当前做的哪些更新还没有暂存，有哪些更新已经暂存起来准备好了下次提交？ `git diff` 会使用文件补丁的格式显示具体添加和删除的行。我们将 readme.txt 文件中的 \"version 1.0.3\" 修改为 \"version 1.0.3_beta\"，然后继续在头部插入一行 \"version 1.0.4\"，查看状态：![](/images/posts/git/modify_add_2.png)要查看尚未暂存的文件了更新了哪些内容，使用 `git diff`：![](/images/posts/git/diff_not_staged.png)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 `git diff --staged` 命令。来看看实际的效果：![](/images/posts/git/diff_staged.png)注意，`git diff` 不跟参数是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。我们将刚做的修改提交到版本库中。在此之前，一定要确认还有什么修改过的或新建的文件还没有 `git add` 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：![](/images/posts/git/modify_commit.png)### 3. 撤销修改和删除文件 ####### 3.1 撤销修改 ###我现在在 readme.txt 文件里面头部插入一行内容为：version 1.0.5，我们先查看一下：![](/images/posts/git/modify_add_3.png)在未提交之前，如果发现添加的内容有误，得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 `git add` 添加到暂存区，最后 commit。第二：使用 `git reset --hard HEAD^` 回退到上一个版本（稍后讲解）。第三：通过上图我们可以看到提示使用 `git checkout -- &lt;file&gt;...` 来丢弃已做的修改。![](/images/posts/git/git_checkout.png)命令 `git checkout -- readme.txt` 意思就是，把readme.txt文件在工作区做的修改全部撤销。但对于 readme.txt 的修改也可能存在以下两种情况：一种情况是：readme.txt 修改后，还没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态，上图显示的就是这种情况。另外一种是 readme.txt 已经放入暂存区，接着再一次作了修改，撤销修改就回到添加暂存区后的状态，如下所示：![](/images/posts/git/git_checkout_2.png)再作一次修改：![](/images/posts/git/git_checkout_3.png)撤销修改后：![](/images/posts/git/git_checkout_4.png)我们可以看到，撤销修改回到的状态是将 readme.txt 添加到暂存区后的状态。#### 3.2 删除文件 ####现在我们在工作区添加一个文件 profile.txt，然后提交。如下所示：![](/images/posts/git/add_profile.png)这时，我们发现刚添加的文件有错误，需要删除。一般情况下，我们直接在工作区将刚添加的 profile.txt 文件删除，但当我们再使用 `git status` 时，情况如下：![](/images/posts/git/delete_file.png)此时有两个选择，一个是使用 `git add/rm &lt;file&gt;...` 删除后再提交保存到版本库，一个是撤销删除操作。提交保存到版本库：![](/images/posts/git/git_add_rm.png)或![](/images/posts/git/git_add_rm_2.png)使用 `git add/rm &lt;file&gt;...` 是将状态存入暂存区，然后使用 `git commit -m 'info'` 提交保存到版本库中。使用 `git checkout -- &lt;file&gt;...` 撤销删除的操作：![](/images/posts/git/git_add_rm_3.png)需要注意的是，当不是通过直接在工作区删除文件，而是通过 `git rm &lt;file&gt;...` 删除了工作区文件，需要通过版本回退的方式撤销删除动作。### 4. 版本回退 ####### 4.1 查看提交历史 ####在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 `git log` 命令查看。![](/images/posts/git/git_log.png)默认不用任何参数的话，`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进显示提交说明。`git log` 有个常用的 --pretty 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 oneline 将每个提交放在一行显示，这在提交数很大时非常有用。![](/images/posts/git/git_log_pretty_oneline.png)#### 4.2 回退 ####为方便演示，我再多次修改并提交版本库。![](/images/posts/git/modify_add_more.png)现在我想使用版本回退操作，把当前的版本回退到上一个版本，使用命令： $ git reset –hard HEAD^12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758该命令的作用是重置当前分支的 HEAD 为指定的 HEAD^（HEAD^ 表示当前版本的上一个版本，也可以用 HEAD^^ 表示上上一个版本，以此类推），同时重置暂存区和工作区，与指定的 HEAD^ 一致。![](/images/posts/git/reset_head.png)那如果再向前回退4个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：`git reset --hard HEAD~4` 即可：![](/images/posts/git/reset_head_4.png)使用 `git log` 查看日志：![](/images/posts/git/git_log_reset.png)可以看到，现在版本为最初始化的第一个版本信息。现在又有一个问题出现了，如果我在版本回退时发现现在回退到的这个版本不是我所需要的，而是需要回退到 version 1.0.4 所在的版本，又该怎么办呢？`git log` 不能察看已经删除了的 commit 记录，`git reflog` 则可以查看所有分支的所有操作记录（包括 commit 和 reset 的操作），包括已经被删除的 commit 记录。![](/images/posts/git/git_reflog.png)最前边一列是对应各版本的版本号，我们可以通过版本号来实现回退：![](/images/posts/git/git_reset_version.png)现在我们再查看，readme.txt 文件中的内容就为我们需要回退到的版本内容了。## 七、分支管理 ##几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。在前边的图片中，我们基本都可以看到这样的内容：![](/images/posts/git/default_master.png)这是每次操作所在的分支说明，master 分支是默认分支。### 1. 新建与合并分支 ###实际工作中（比如开发一个网站）大概会是这样的工作流程：1. 为实现某个新的需求，创建一个分支。 2. 在这个分支上开展工作。假设此时，你突然接到一个电话说有个很严重的 bug 需要紧急修复，那么可以接着按照下面的步骤处理：3. 返回到原先已经发布到生产服务器上的分支。 4. 为这次紧急修复建立一个新分支，并在其中修复问题。5. 通过测试后，回到生产服务器所在的分支，将修复分支合并进来，然后再推送到生产服务器上。6. 切换到之前实现新需求的分支，继续工作。#### 1.1 新建分支 ####**创建分支**使用如下命令来创建分支： $ git branch branch_name123456![](/images/posts/git/git_branch_dev.png)**切换分支**我们已经创建了一个新分支：dev，但当前分支仍然为 master 分支，所以还需要使用切换分支命令来切换操作： $ git checkout branch_name123456789![](/images/posts/git/git_branch_checkout.png)已成功切换到 dev 分支了。**创建并切换分支**我们也可以使用如下命令来新建并切换分支： $ git checkout -b branch_name123456![](/images/posts/git/git_branch_checkout_bug.png)**列出分支**使用命令： $ git branch12345678910111213141516171819202122232425262728如：![](/images/posts/git/git_branch.png)**向分支提交版本库**下面我们向新分支 dev 中添加一个文件：![](/images/posts/git/add_index_to_dev.png)我们来看一下工作区目录结构：![](/images/posts/git/dev_folder.png)接下来切换回 master 分支：![](/images/posts/git/git_checkout_master.png)再看一下工作区目录结构：![](/images/posts/git/master_folder.png)比较两个不同分支下的目录结构，我们可以发现，在 dev 分支下保存到版本库中的文件 index.html，在 master 分支下看不见了。这是因为当切换分支的时候，Git 会用该分支的最后提交的快照替换工作目录的内容。#### 1.2 合并分支 ####如果我们需要将在 dev 分支版本库中的内容也添加到 master 分支中来，则需要合并分支： $ git merge123456789101112131415161718192021222324252627282930313233343536373839404142![](/images/posts/git/git_merge.png)合并后工作区目录结构：![](/images/posts/git/dev_folder.png)当然，合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。**合并冲突**首先在 master 分支下新建一个文本文件 site.txt 并提交，文本内容为 \"http://www.mobiletrain.org/\"，如下所示：![](/images/posts/git/add_site.png)创建一个新分支 dev，在新分支中修改 site.txt 并提交，文件内容为 \"http://www.1000phone.com/\"，如下所示：![](/images/posts/git/modify_site.png)切换回 master 分支，再查看 site.txt 文件内容：![](/images/posts/git/git_checkout_master_2.png)当前 master 分支中没有未提交的修改，我们继续在 master 分支中修改 site.txt，向文件末尾添加一行 \"http://www.codingke.com/\" 的内容：![](/images/posts/git/modify_site_2.png)接下来，把 dev 分支中的内容合并过来：![](/images/posts/git/git_merge_2.png)这时，一个合并冲突就出现了，我们需要手动修改冲突，修改完毕后：![](/images/posts/git/git_merge_conflict.png)确保冲突合并修改完毕后，提交到版本库中：![](/images/posts/git/git_merge_conflict_fixed.png)#### 1.3 删除分支 ####合并完成后，我们可以接着删除dev分支了，命令： $ git branch -d branch_name123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354如：![](/images/posts/git/git_branch_del.png)## 八、Git 远程仓库 ##Git 并不像 SVN 那样有个中心服务器。目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。你就需要将数据放到一台其他开发人员能够连接的服务器上。以下的介绍使用了 GitHub 作为远程仓库。### 1. GitHub 简介 ###如果你是一枚 Coder，但是你不知道 GitHub，那么我觉的你就不是一个菜鸟级别的 Coder，因为你压根不是真正 Coder，你只是一个 Code 搬运工。---- 菜鸟教程如是说。&gt; GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。&gt; &gt; GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。除了允许个人和组织创建和访问代码库以外，它也提供了一些方便社会化软件开发的功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于显示开发者们怎样在代码库上工作以及软件的开发活跃程度。&gt; &gt; 截止到2015年，GitHub已经有超过九百万注册用户和2110万代码库。事实上已经成为了世界上最大的代码存放网站和开源社区。这是[维基百科](https://zh.wikipedia.org/wiki/GitHub)对 GitHub 的介绍。我们先作为免费用户来使用一下 GitHub。免费用户只能使用公共仓库，也就是代码要公开。### 2. 注册账户 ###要想使用 GitHub，第一步当然是注册 GitHub 账号了。如果你已经注册过 GitHub 账号，请跳过这一步。GitHub 官网地址：[https://github.com/](https://github.com/)。![](/images/posts/git/register_github.png)根据向导注册即可，不再赘述。### 3. 创建仓库 ###登录 GitHub 后，点击导航栏中的 \"+\" 号，打开下拉菜单，选择 \"New Repository\" 新建仓库：![](/images/posts/git/create_repository.png)输入新仓库名称，其它直接使用默认值，点击 \"Create repository\" 按钮，创建仓库。![](/images/posts/git/create_repository_2.png)仓库创建成功后，可看到三种方式向仓库中添加版本库内容：![](/images/posts/git/create_repository_3.png)### 4. 配置 SSH key ###由于我们本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以需要作一下配置。**创建 SSH key**在用户主目录下，查看是否有一个名为 .ssh 的文件夹，如果有，打开查看是否存在 id_rsa 和 id_rsa.pub 这两个文件，如果存在，则可以复制 id_rsa.pub 文件中的内容，然后跳过此步骤（假如文件存在，但自己从未创建过 SSH key，也可以继续进行如下步骤），如果这些都不存在，则输入如下命令： $ ssh-keygen -t rsa -C ‘your_email@youremail.com’12345678910111213141516171819202122将 your_email@youremail.com 改为你在 GitHub 上注册的邮箱，之后会要求确认路径和输入密码，我直接使用默认的一路回车完成。成功的话会在用户主目录下生成 .ssh 文件夹，进入文件夹，使用文本工具打开 id_rsa.pub，我们可以看到文件里边一串文件信息，这是生成的 key，全选复制这些内容，以备后用。**配置 GitHub 账户**回到 GitHub，进入 Settings（配置）：![](/images/posts/git/account_setting.png)左边选择SSH and GPG Keys，打开页面中选择 New SSH key：![](/images/posts/git/ssh_keys.png)Title 随便填，Key 粘贴之前复制到剪贴板上的内容：![](/images/posts/git/add_ssh_key.png)点击 Add SSH key 按钮，完成配置：![](/images/posts/git/add_ssh_key_ok.png)为了验证是否成功，在 git bash 下输入： $ ssh -T git@github.com12345678910111213141516171819202122232425262728如果是第一次的会提示是否 Are you sure you want to continue connecting (yes/no)? ，输入 yes 就会看到：You've successfully authenticated, but GitHub does not provide shell access。这就表示已成功连上 GitHub。**远程仓库信息**要查看远程库的详细信息，可使用 `git remote –v`：![](/images/posts/git/remote.png)fetch 表示抓取分支，push 表示推送分支。### 5. 推送本地仓库至 GitHub ###我们在 GitHub 上创建仓库时，已经看到如下提示：![](/images/posts/git/push_an_existing_repository.png)根据该提示，在本地 git_test 仓库下运行这两条命令：![](/images/posts/git/git_push.png)输入登录 GitHub 的用户名与密码，等待本地仓库推送至 GitHub 完毕即可。推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样了：![](/images/posts/git/git_push_success.png)以后只要在本地作了提交，就可以通过如下命令： $ git push origin master123456789101112131415161718把本地 master 分支的最新修改推送到 GitHub 上了。现在我们就拥有了真正的分布式版本库了。### 6. 抓取远程仓库分支 ###如果是团队合作的项目，那么当有其他同事向远程仓库提交了新数据后，我们又该如何将最新版本数据从远程仓库同步到本地呢？我直接在 GitHub 的仓库中添加了一个新文件 new_file.txt（内容为：this file was created on the server），来模拟其他同事的提交：![](/images/posts/git/new_file_on_server.png)在更新最新版本到本地之前，我们先通过 `git status` 查看下本地状态，这样可以知道是否有修改过的文件没有提交，因为如果本地修改的文件没有提交而服务器中存在提交修改的版本，那么更新过程中导致更新过程中就可能产生冲突，所以通过查看状态确保本地全部提交过：![](/images/posts/git/git_status.png)下面我们来更新本地仓库，使用命令： $ git pull12345678910111213141516171819202122232425262728![](/images/posts/git/git_pull.png)查看本地工作区文件，可以看到服务器上的文件同步到本地仓库了：![](/images/posts/git/git_pull_2.png)也可以使用 `git fetch` 来抓取分支，它与 `git pull` 的区别在于：`git fetch` 相当于是从远程获取最新版本到本地，不会自动merge；`git pull` 相当于是从远程获取最新版本并merge到本地。### 7. 克隆远程版本库 ###上面我们了解了先有本地库，后有远程库的时候，如何关联远程库。现在我们想，假如先有的是远程库，要把远程库的内容克隆到本地来 如何克隆呢？首先，登录 GitHub，创建一个新的仓库，名字叫 git_test_clone。如下：![](/images/posts/git/new_repository.png)远程仓库准备好后，我们先复制远程仓库访问路径 URL：![](/images/posts/git/copy_address.png)我先在 F 盘下新建一个文件夹 clone，将从服务器上克隆的仓库放入该文件夹下，则执行如下命令克隆仓库： $ git clone URL1234567891011121314![](/images/posts/git/clone_repository.png)克隆成功后，我们就可以进入对应目录进行本地文件编辑了。![](/images/posts/git/clone_success.png)## 九、总结 ##到此，简单的 Git 使用就介绍完毕了，下面总结一下常用到的 Git 命令：日常使用命令：![](/images/posts/git/most_use.png) 在当前目录新建一个Git代码库$ git init 下载一个项目和它的整个代码历史$ git clone [url] 显示当前的Git配置$ git config –list 设置提交代码时的用户信息$ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]” 添加指定文件到暂存区$ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录$ git add [dir] 添加当前目录的所有文件到暂存区$ git add . 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] … 提交暂存区到仓库区$ git commit -m [message] 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a 提交时显示所有diff信息$ git commit -v 列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 新建一个分支，并切换到该分支$ git checkout -b [branch] 切换到指定分支，并更新工作区$ git checkout [branch-name] 切换到上一个分支$ git checkout - 合并指定分支到当前分支$ git merge [branch] 删除分支$ git branch -d [branch-name] 删除远程分支$ git push origin –delete [branch-name]$ git branch -dr [remote/branch] 显示有变更的文件$ git status 显示当前分支的版本历史$ git log 显示暂存区和工作区的差异$ git diff 显示暂存区和上一个commit的差异$ git diff –cached [file] 显示当前分支的最近几次提交$ git reflog 下载远程仓库的所有变动$ git fetch [remote] 显示所有远程仓库$ git remote -v 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 上传本地指定分支到远程仓库$ git push [remote] [branch] 恢复暂存区的指定文件到工作区$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致$ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset –hard [commit]``` 参考资料： http://www.cnblogs.com/wzyxidian/p/5520002.html http://www.runoob.com/git/git-tutorial.html http://www.cnblogs.com/tugenhua0707/p/4050072.html http://www.runoob.com/git/git-tutorial.html http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[{"name":"前端","slug":"前端","permalink":"http://zhanhongzj.github.io/categories/前端/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://zhanhongzj.github.io/tags/工具/"}]}]}